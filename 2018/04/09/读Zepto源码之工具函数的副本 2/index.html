<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>读zepto源码之工具函数 | 郭小胖博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><img class="avatarShow" src="https://avatars0.githubusercontent.com/u/16914233?s=400&amp;u=9ea9dc30bf32d1bc2c290e598e40a3fe8ae043c1&amp;v=4" alt=""><h1 class="hidden">读zepto源码之工具函数</h1><a id="logo" href="/.">郭小胖博客</a><p class="description">拒绝油腻，锻炼身体</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">读zepto源码之工具函数</h1><div class="post-meta">Apr 9, 2018</div><div class="post-content"><h3 id="读zepto源码之工具函数"><a href="#读zepto源码之工具函数" class="headerlink" title="读zepto源码之工具函数"></a>读zepto源码之工具函数</h3><p>Zepto 提供了丰富的工具函数，下面来一一解读。</p>
<h3 id="源码版本"><a href="#源码版本" class="headerlink" title="源码版本"></a>源码版本</h3><p>本文阅读的源码为 <a href="https://github.com/madrobby/zepto/tree/v1.2.0" target="_blank" rel="noopener">zepto1.2.0</a></p>
<h2 id="GitBook"><a href="#GitBook" class="headerlink" title="GitBook"></a>GitBook</h2><p>《<a href="https://yeyuqiudeng.gitbooks.io/reading-zepto/content/" target="_blank" rel="noopener">reading-zepto</a>》</p>
<h2 id="extend"><a href="#extend" class="headerlink" title="$.extend"></a>$.extend</h2><p><code>$.extend</code> 方法可以用来扩展目标对象的属性。目标对象的同名属性会被源对象的属性覆盖。</p>
<p><code>$.extend</code> 其实调用的是内部方法 <code>extend</code>， 所以我们先看看内部方法 <code>extend</code> 的具体实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">target, source, deep</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (key <span class="keyword">in</span> source)  <span class="comment">// 遍历源对象的属性值</span></span><br><span class="line">            <span class="keyword">if</span> (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123; <span class="comment">// 如果为深度复制，并且源对象的属性值为纯粹对象或者数组</span></span><br><span class="line">                <span class="keyword">if</span> (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) <span class="comment">// 如果为纯粹对象</span></span><br><span class="line">                    target[key] = &#123;&#125;  <span class="comment">// 如果源对象的属性值为纯粹对象，并且目标对象对应的属性值不为纯粹对象，则将目标对象对应的属性值置为空对象</span></span><br><span class="line">                <span class="keyword">if</span> (isArray(source[key]) &amp;&amp; !isArray(target[key])) <span class="comment">// 如果源对象的属性值为数组，并且目标对象对应的属性值不为数组，则将目标对象对应的属性值置为空数组</span></span><br><span class="line">                    target[key] = []</span><br><span class="line">                extend(target[key], source[key], deep) <span class="comment">// 递归调用extend函数</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source[key] !== <span class="literal">undefined</span>) target[key] = source[key]  <span class="comment">// 不对undefined值进行复制</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>extend</code> 的第一个参数 <code>taget</code> 为目标对象， <code>source</code> 为源对象， <code>deep</code> 表示是否为深度复制。当 <code>deep</code> 为 <code>true</code> 时为深度复制， <code>false</code> 时为浅复制。</p>
<ol>
<li><p><code>extend</code> 函数用 <code>for···in</code> 对 <code>source</code> 的属性进行遍历</p>
</li>
<li><p>如果 <code>deep</code> 为 <code>false</code> 时，只进行浅复制，将 <code>source</code> 中不为 <code>undefined</code> 的值赋值到 <code>target</code> 对应的属性中（注意，这里用的是 <code>!==</code>，不是 <code>!=</code> ，所以只排除严格为 <code>undefined</code> 的值，不包含 <code>null</code> ）。如果 <code>source</code> 对应的属性值为对象或者数组，会保持该对象或数组的引用。</p>
</li>
<li><p>如果 <code>deep</code> 为 <code>true</code> ，并且 <code>source</code> 的属性值为纯粹对象或者数组时</p>
<p>3.1. 如果 <code>source</code> 的属性为纯粹对象，并且 <code>target</code> 对应的属性不为纯粹对象时，将 <code>target</code> 的对应属性设置为空对象</p>
<p>3.2. 如果 <code>source</code> 的属性为数组，并且 <code>target</code> 对应属性不为数组时，将 <code>target</code> 的对应属性设置为空数组</p>
<p>3.3. 将 <code>source</code> 和 <code>target</code> 对应的属性及 <code>deep</code> 作为参数，递归调用 <code>extend</code> 函数，以实现深度复制。</p>
</li>
</ol>
<p>现在，再看看 <code>$.extend</code> 的具体实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.extend = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> deep, args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> target == <span class="string">'boolean'</span>) &#123;</span><br><span class="line">            deep = target</span><br><span class="line">            target = args.shift()</span><br><span class="line">        &#125;</span><br><span class="line">        args.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123; extend(target, arg, deep) &#125;)</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 在说原理之前，先来看看 <code>$.extend</code> 的调用方式，调用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.extend(target, [source, [source2, ...]])</span><br><span class="line">                  或</span><br><span class="line">$.extend(<span class="literal">true</span>, target, [source, ...])</span><br></pre></td></tr></table></figure>
<p>在 <code>$.extend</code> 中，如果不需要深度复制，第一个参数可以是目标对象 <code>target</code>, 后面可以有多个 <code>source</code> 源对象。如果需要深度复制，第一个参数为 <code>deep</code> ，第二个参数为 <code>target</code> ，为目标对象，后面可以有多个 <code>source</code> 源对象。</p>
<p><code>$.extend</code> 函数的参数设计得很优雅，不需要深度复制时，可以不用显式地将 <code>deep</code> 置为 <code>false</code>。这是如何做到的呢？</p>
<p>在 <code>$.extend</code> 函数中，定义了一个数组 <code>args</code>，用来接受除第一个参数外的所有参数。</p>
<p>然后判断第一个参数 <code>target</code> 是否为布尔值，如果为布尔值，表示第一个参数为 <code>deep</code> ，那么第二个才为目标对象，因此需要重新为 <code>target</code> 赋值为 <code>args.shift()</code> 。</p>
<p>最后就比较简单了，循环源对象数组 <code>args</code>， 分别调用 <code>extend</code> 方法，实现对目标对象的扩展。</p>
<h2 id="each"><a href="#each" class="headerlink" title="$.each"></a>$.each</h2><p><code>$.each</code> 用来遍历数组或者对象，源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.each = <span class="function"><span class="keyword">function</span>(<span class="params">elements, callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i, key</span><br><span class="line">        <span class="keyword">if</span> (likeArray(elements)) &#123;  <span class="comment">// 类数组</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements.length; i++)</span><br><span class="line">                <span class="keyword">if</span> (callback.call(elements[i], i, elements[i]) === <span class="literal">false</span>) <span class="keyword">return</span> elements</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 对象</span></span><br><span class="line">            <span class="keyword">for</span> (key <span class="keyword">in</span> elements)</span><br><span class="line">                <span class="keyword">if</span> (callback.call(elements[key], key, elements[key]) === <span class="literal">false</span>) <span class="keyword">return</span> elements</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elements</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>先来看看调用方式：<code>$.each(collection, function(index, item){ ... })</code></p>
<p><code>$.each</code> 接收两个参数，第一个参数 <code>elements</code> 为需要遍历的数组或者对象，第二个 <code>callback</code> 为回调函数。</p>
<p>如果 <code>elements</code> 为数组，用 <code>for</code> 循环，调用 <code>callback</code> ，并且将数组索引 <code>index</code>  和元素值 <code>item</code> 传给回调函数作为参数；如果为对象，用 <code>for···in</code> 遍历属性值，并且将属性 <code>key</code> 及属性值传给回调函数作为参数。</p>
<p>注意回调函数调用了 <code>call</code> 方法，<code>call</code> 的第一个参数为当前元素值或当前属性值，所以回调函数的上下文变成了当前元素值或属性值，也就是说回调函数中的 <code>this</code> 指向的是 <code>item</code> 。这在dom集合的遍历中相当有用。</p>
<p>在遍历的时候，还对回调函数的返回值进行判断，如果回调函数返回 <code>false</code> （<code>if (callback.call(elements[i], i, elements[i]) === false)</code>） ，立即中断遍历。</p>
<p><code>$.each</code> 调用结束后，会将遍历的数组或对象（ <code>elements</code> ）返回。</p>
<h2 id="map"><a href="#map" class="headerlink" title="$.map"></a>$.map</h2><p>可以遍历数组（类数组）或对象中的元素，根据回调函数的返回值，将返回值组成一个新的数组，并将该数组扁平化后返回，会将 <code>null</code> 及 <code>undefined</code> 排除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$.map = <span class="function"><span class="keyword">function</span>(<span class="params">elements, callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value, values = [],</span><br><span class="line">            i, key</span><br><span class="line">        <span class="keyword">if</span> (likeArray(elements))</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">                value = callback(elements[i], i)</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="literal">null</span>) values.push(value)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span> (key <span class="keyword">in</span> elements) &#123;</span><br><span class="line">                value = callback(elements[key], key)</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="literal">null</span>) values.push(value)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> flatten(values)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>先来看看调用方式： <code>$.map(collection, function(item, index){ ... })</code></p>
<p><code>elements</code> 为类数组或者对象。<code>callback</code> 为回调函数。当为类数组时，用 <code>for</code> 循环，当为对象时，用 <code>for···in</code> 循环。并且将对应的元素（属性值）及索引（属性名）传递给回调函数，如果回调函数的返回值不为 <code>null</code> 或者 <code>undefined</code> ，则将返回值存入新数组中，最后将新数组扁平化后返回。</p>
<h2 id="camelCase"><a href="#camelCase" class="headerlink" title="$.camelCase"></a>$.camelCase</h2><p>该方法是将字符串转换成驼峰式的字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.camelCase = camelize</span><br></pre></td></tr></table></figure>
<p><code>$.camelCase</code> 调用的是内部方法 <code>camelize</code> ,该方法在前一篇文章《<a href="https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8B%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95.md#camelize" target="_blank" rel="noopener">读Zepto源码之内部方法</a>》中已有阐述，本篇文章就不再展开。</p>
<h2 id="contains"><a href="#contains" class="headerlink" title="$.contains"></a>$.contains</h2><p>用来检查给定的父节点中是否包含有给定的子节点，源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.contains = <span class="built_in">document</span>.documentElement.contains ?</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">parent, node</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> parent !== node &amp;&amp; parent.contains(node)</span><br><span class="line">        &#125; :</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">parent, node</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (node &amp;&amp; (node = node.parentNode))</span><br><span class="line">                <span class="keyword">if</span> (node === parent) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>先来看看调用：<code>$.contains(parent, node)</code></p>
<p>参数 <code>parent</code> 为父子点，<code>node</code> 为子节点。</p>
<p><code>$.contains</code> 的主体是一个三元表达式，返回的是一个匿名函数。三元表达式的条件是 <code>document.documentElement.contains</code>， 用来检测浏览器是否支持 <code>contains</code> 方法，如果支持，则直接调用 <code>contains</code> 方法，并且将 <code>parent</code> 和 <code>node</code> 为同一个元素的情况排除。</p>
<p>否则，返回另一外匿名函数。该函数会一直向上寻找 <code>node</code> 元素的父元素，如果能找到跟 <code>parent</code> 相等的父元素，则返回 <code>true</code>， 否则返回 <code>false</code></p>
<h2 id="grep"><a href="#grep" class="headerlink" title="$.grep"></a>$.grep</h2><p>该函数其实就是数组的 <code>filter</code> 函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.grep = <span class="function"><span class="keyword">function</span>(<span class="params">elements, callback</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> filter.call(elements, callback)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>从源码中也可以看出，<code>$.grep</code> 调用的就是数组方法 <code>filter</code></p>
<h2 id="inArray"><a href="#inArray" class="headerlink" title="$.inArray"></a>$.inArray</h2><p>返回指定元素在数组中的索引值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.inArray = <span class="function"><span class="keyword">function</span>(<span class="params">elem, array, i</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> emptyArray.indexOf.call(array, elem, i)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>先来看看调用 <code>$.inArray(element, array, [fromIndex])</code></p>
<p>第一个参数 <code>element</code> 为指定的元素，第二个参数为 <code>array</code> 为数组， 第三个参数 <code>fromIndex</code> 为可选参数，表示从哪个索引值开始向后查找。</p>
<p><code>$.inArray</code> 其实调用的是数组的  <code>indexOf</code> 方法，所以传递的参数跟 <code>indexOf</code> 方法一致。</p>
<h2 id="isArray"><a href="#isArray" class="headerlink" title="$.isArray"></a>$.isArray</h2><p>判断是否为数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.isArray = isArray</span><br></pre></td></tr></table></figure>
<p><code>$.isArray</code> 调用的是内部方法 <code>isArray</code> ，该方法在前一篇文章《<a href="https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8B%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95.md#isarray" target="_blank" rel="noopener">读Zepto源码之内部方法</a>》中已有阐述。</p>
<h2 id="isFunction"><a href="#isFunction" class="headerlink" title="$.isFunction"></a>$.isFunction</h2><p>判读是否为函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.isFunction = isFunction</span><br></pre></td></tr></table></figure>
<p><code>$.isFunction</code> 调用的是内部方法 <code>isFunction</code> ，该方法在前一篇文章《<a href="https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8B%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95.md#isfunction--isobject" target="_blank" rel="noopener">读Zepto源码之内部方法</a>》中已有阐述。</p>
<h2 id="isNumeric"><a href="#isNumeric" class="headerlink" title="$.isNumeric"></a>$.isNumeric</h2><p>是否为数值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.isNumeric = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> num = <span class="built_in">Number</span>(val), <span class="comment">// 将参数转换为Number类型</span></span><br><span class="line">            type = <span class="keyword">typeof</span> val</span><br><span class="line">        <span class="keyword">return</span> val != <span class="literal">null</span> &amp;&amp; </span><br><span class="line">          type != <span class="string">'boolean'</span> &amp;&amp;</span><br><span class="line">            (type != <span class="string">'string'</span> || val.length) &amp;&amp;</span><br><span class="line">          !<span class="built_in">isNaN</span>(num) &amp;&amp;</span><br><span class="line">          <span class="built_in">isFinite</span>(num) </span><br><span class="line">          || <span class="literal">false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>判断是否为数值，需要满足以下条件</p>
<ol>
<li>不为 <code>null</code></li>
<li>不为布尔值</li>
<li>不为NaN(当传进来的参数不为数值或如<code>&#39;123&#39;</code>这样形式的字符串时，都会转换成NaN)</li>
<li>为有限数值</li>
<li>当传进来的参数为字符串的形式，如<code>&#39;123&#39;</code> 时，会用到下面这个条件来确保字符串为数字的形式，而不是如 <code>123abc</code> 这样的形式。<code>(type != &#39;string&#39; || val.length) &amp;&amp; !isNaN(num)</code> 。这个条件的包含逻辑如下：如果为字符串类型，并且为字符串的长度大于零，并且转换成数组后的结果不为NaN，则断定为数值。（因为 <code>Number(&#39;&#39;)</code> 的值为 <code>0</code>）</li>
</ol>
<h2 id="isPlainObject"><a href="#isPlainObject" class="headerlink" title="$.isPlainObject"></a>$.isPlainObject</h2><p>是否为纯粹对象，即以 <code>{}</code> 常量或 <code>new Object()</code> 创建的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.isPlainObject = isPlainObject</span><br></pre></td></tr></table></figure>
<p><code>$.isPlainObject</code> 调用的是内部方法<code>isPlainObject</code> ，该方法在前一篇文章《<a href="https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8B%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95.md#isplainobject" target="_blank" rel="noopener">读Zepto源码之内部方法</a>》中已有阐述。</p>
<h2 id="isWindow"><a href="#isWindow" class="headerlink" title="$.isWindow"></a>$.isWindow</h2><p>是否为浏览器的 <code>window</code> 对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.isWindow = isWindow</span><br></pre></td></tr></table></figure>
<p><code>$.isWindow</code> 调用的是内部方法 <code>isWindow</code> ，该方法在前一篇文章《<a href="https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8B%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95.md#iswindow" target="_blank" rel="noopener">读Zepto源码之内部方法</a>》中已有阐述。</p>
<h2 id="noop"><a href="#noop" class="headerlink" title="$.noop"></a>$.noop</h2><p>空函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.noop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这个在需要传递回调函数作为参数，但是又不想在回调函数中做任何事情的时候会非常有用，这时，只需要传递一个空函数即可。</p>
<h2 id="parseJSON"><a href="#parseJSON" class="headerlink" title="$.parseJSON"></a>$.parseJSON</h2><p>将标准JSON格式的字符串解释成JSON</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.JSON) $.parseJSON = <span class="built_in">JSON</span>.parse</span><br></pre></td></tr></table></figure>
<p>其实就是调用原生的 <code>JSON.parse</code>， 并且在浏览器不支持的情况下，<code>zepto</code> 还不提供这个方法。</p>
<h2 id="trim"><a href="#trim" class="headerlink" title="$.trim"></a>$.trim</h2><p>删除字符串头尾的空格</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.trim = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str == <span class="literal">null</span> ? <span class="string">""</span> : <span class="built_in">String</span>.prototype.trim.call(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果参数为 <code>null</code> 或者 <code>undefined</code> ，则直接返回空字符串，否则调用字符串原生的 <code>trim</code> 方法去除头尾的空格。</p>
<h2 id="type"><a href="#type" class="headerlink" title="$.type"></a>$.type</h2><p>类型检测</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.type = type</span><br></pre></td></tr></table></figure>
<p><code>$.type</code> 调用的是内部方法 <code>type</code> ，该方法在前一篇文章《<a href="https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8B%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95.md#数据类型检测" target="_blank" rel="noopener">读Zepto源码之内部方法</a>》中已有阐述。</p>
<p>能检测的类型有 <code>&quot;Boolean Number String Function Array Date RegExp Object Error&quot;</code></p>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ol>
<li><a href="https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8B%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84.md" target="_blank" rel="noopener">读Zepto源码之代码结构</a></li>
<li><a href="https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8B%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95.md" target="_blank" rel="noopener">读 Zepto 源码之内部方法</a></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.css88.com/doc/zeptojs_api/" target="_blank" rel="noopener">Zepto中文文档</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/contains" target="_blank" rel="noopener">Node.contains()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?v=example" target="_blank" rel="noopener">Array.prototype.indexOf()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim" target="_blank" rel="noopener">String.prototype.trim()</a></li>
</ul>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)</a></p>
<p>最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见：  <img src="https://raw.githubusercontent.com/yeyuqiudeng/resource/master/images/qrcode_front-end-article.jpg" alt=""> </p>
<p>作者：对角另一面</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/04/09/读Zepto源码之工具函数/">读zepto源码之工具函数</a><a class="next" href="/2018/04/09/读Zepto源码之工具函数的副本 3/">读zepto源码之工具函数</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://changguo.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/05/09/读Zepto源码之代码结构/">读Zepto源码之代码结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/09/读Zepto源码之代码结构的副本 3/">读Zepto源码之代码结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/09/读Zepto源码之代码结构的副本 4/">读Zepto源码之代码结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/09/读Zepto源码之代码结构的副本 5/">读Zepto源码之代码结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/09/读Zepto源码之代码结构的副本 6/">读Zepto源码之代码结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/09/读Zepto源码之代码结构的副本 7/">读Zepto源码之代码结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/09/读Zepto源码之代码结构的副本/">读Zepto源码之代码结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/09/读Zepto源码之代码结构的副本 2/">读Zepto源码之代码结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/09/读Zepto源码之工具函数/">读zepto源码之工具函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/09/读Zepto源码之工具函数的副本 2/">读zepto源码之工具函数</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">郭小胖博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"></a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>