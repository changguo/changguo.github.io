{"meta":{"title":"郭小胖博客","subtitle":"拒绝油腻，锻炼身体","description":null,"author":"郭小胖","url":"http://changguo.io"},"pages":[],"posts":[{"title":"读Zepto源码之代码结构","slug":"读Zepto源码之代码结构","date":"2018-05-09T12:50:33.000Z","updated":"2018-05-09T13:54:44.685Z","comments":true,"path":"2018/05/09/读Zepto源码之代码结构/","link":"","permalink":"http://changguo.io/2018/05/09/读Zepto源码之代码结构/","excerpt":"","text":"读Zepto源码之代码结构虽然最近工作中没有怎么用 zepto ，但是据说 zepto 的源码比较简单，而且网上的资料也比较多，所以我就挑了 zepto 下手，希望能为以后阅读其他框架的源码打下基础吧。 源码版本本文阅读的源码为 zepto1.2.0 阅读zepto之前需要了解 javascript 原型链和闭包的知识，推荐阅读王福朋的这篇文章:深入理解 Javascript 原型和闭包，写得很详细，也非常易于阅读。 GitBook《reading-zepto》 源码结构整体结构123456var Zepto = (function () &#123; ...&#125;)()window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto) 如果在编辑器中将 zepto 的源码折叠起来，看到的就跟上面的代码一样。 zepto 的核心是一个闭包，加载完毕后立即执行。然后暴露给全局变量 zepto ，如果 $ 没有定义，也将 $ 赋值为 Zepto 。 核心结构在这部分中，我们先不关注 zepto 的具体实现，只看核心的结构，因此我将zepto中的逻辑先移除，得出如下的核心结构： 123456789101112131415161718192021222324252627282930313233var zepto = &#123;&#125;, $function Z(doms) &#123; var len = doms.length for (var i = 0; i &lt; len; i++) &#123; this[i] = doms[i] &#125; this.length = doms.length&#125;zepto.Z = function(doms) &#123; return new Z(doms)&#125;zepto.init = function(doms) &#123; var doms = ['domObj1','domObj2','domObj3'] return zepto.Z(doms)&#125;$ = function() &#123; return zepto.init()&#125;$.fn = &#123; constructor: zepto.Z, method: function() &#123; return this &#125;&#125;zepto.Z.prototype = Z.prototype = $.fnreturn $ 在源码中，可以看出， $ 其实是一个函数，同时在 $ 身上又挂了很多属性和方法（这里体现在 $.fn 身上，其他的会在后续的文章中谈到）。 我们在使用 zepto 的时候，会用 $ 去获取 dom ，并且在这些 dom 对象身上都有 zepto 定义的各种各样的操作方法。 从上面的伪代码中，可以看到，$ 其实调用了 zepto.init() 方法，在 init 方法中，会获取到 dom 元素集合，然后将集合交由 zepto.Z() 方法处理，而 zepto.Z 方法返回的是函数 Z 的一个实例。 函数 Z 会将 doms 展开，变成实例的属性，key 为对应 domObj 的索引， 并且设置实例的 length 属性。 zepto.Z.prototype = Z.prototype = $.fn读到这里，你可能会有点疑惑，$ 最终返回的是 Z 函数的实例，但是 Z 函数明明没有 dom 的操作方法啊，这些操作方法都定义在 $.fn 身上，为什么 $ 可以调用这些方法呢？ 其实关键在于这句代码 Z.prototype = $.fn ，这句代码将 Z 的 prototype 指向 $.fn ，这样，Z 的实例就继承了 $.fn 的方法。 既然这样就已经让 Z 的实例继承了 $.fn 的方法，那 zepto.Z.prototype = $.fn 又是为什么呢？ 如果我们再看源码，会发现有这样的一个方法： 123zepto.isZ = function(object) &#123; return object instanceof zepto.Z&#125; 这个方法是用来判读一个对象是否为 zepto 对象，这是通过判断这个对象是否为 zepto.Z 的实例来完成的，因此需要将 zepto.Z 和 Z 的 prototype 指向同一个对象。 isZ 方法会在 init 中用到，后面也会介绍。 参考 zepto源码分析-代码结构 zepto对象思想与源码分析 zepto设计和源码分析 zepto源码中关于zepto.Z.prototype = $.fn的问题 License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见：","categories":[],"tags":[]},{"title":"读Zepto源码之代码结构","slug":"读Zepto源码之代码结构的副本 3","date":"2018-05-09T12:50:33.000Z","updated":"2018-05-09T13:54:44.685Z","comments":true,"path":"2018/05/09/读Zepto源码之代码结构的副本 3/","link":"","permalink":"http://changguo.io/2018/05/09/读Zepto源码之代码结构的副本 3/","excerpt":"","text":"读Zepto源码之代码结构虽然最近工作中没有怎么用 zepto ，但是据说 zepto 的源码比较简单，而且网上的资料也比较多，所以我就挑了 zepto 下手，希望能为以后阅读其他框架的源码打下基础吧。 源码版本本文阅读的源码为 zepto1.2.0 阅读zepto之前需要了解 javascript 原型链和闭包的知识，推荐阅读王福朋的这篇文章:深入理解 Javascript 原型和闭包，写得很详细，也非常易于阅读。 GitBook《reading-zepto》 源码结构整体结构123456var Zepto = (function () &#123; ...&#125;)()window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto) 如果在编辑器中将 zepto 的源码折叠起来，看到的就跟上面的代码一样。 zepto 的核心是一个闭包，加载完毕后立即执行。然后暴露给全局变量 zepto ，如果 $ 没有定义，也将 $ 赋值为 Zepto 。 核心结构在这部分中，我们先不关注 zepto 的具体实现，只看核心的结构，因此我将zepto中的逻辑先移除，得出如下的核心结构： 123456789101112131415161718192021222324252627282930313233var zepto = &#123;&#125;, $function Z(doms) &#123; var len = doms.length for (var i = 0; i &lt; len; i++) &#123; this[i] = doms[i] &#125; this.length = doms.length&#125;zepto.Z = function(doms) &#123; return new Z(doms)&#125;zepto.init = function(doms) &#123; var doms = ['domObj1','domObj2','domObj3'] return zepto.Z(doms)&#125;$ = function() &#123; return zepto.init()&#125;$.fn = &#123; constructor: zepto.Z, method: function() &#123; return this &#125;&#125;zepto.Z.prototype = Z.prototype = $.fnreturn $ 在源码中，可以看出， $ 其实是一个函数，同时在 $ 身上又挂了很多属性和方法（这里体现在 $.fn 身上，其他的会在后续的文章中谈到）。 我们在使用 zepto 的时候，会用 $ 去获取 dom ，并且在这些 dom 对象身上都有 zepto 定义的各种各样的操作方法。 从上面的伪代码中，可以看到，$ 其实调用了 zepto.init() 方法，在 init 方法中，会获取到 dom 元素集合，然后将集合交由 zepto.Z() 方法处理，而 zepto.Z 方法返回的是函数 Z 的一个实例。 函数 Z 会将 doms 展开，变成实例的属性，key 为对应 domObj 的索引， 并且设置实例的 length 属性。 zepto.Z.prototype = Z.prototype = $.fn读到这里，你可能会有点疑惑，$ 最终返回的是 Z 函数的实例，但是 Z 函数明明没有 dom 的操作方法啊，这些操作方法都定义在 $.fn 身上，为什么 $ 可以调用这些方法呢？ 其实关键在于这句代码 Z.prototype = $.fn ，这句代码将 Z 的 prototype 指向 $.fn ，这样，Z 的实例就继承了 $.fn 的方法。 既然这样就已经让 Z 的实例继承了 $.fn 的方法，那 zepto.Z.prototype = $.fn 又是为什么呢？ 如果我们再看源码，会发现有这样的一个方法： 123zepto.isZ = function(object) &#123; return object instanceof zepto.Z&#125; 这个方法是用来判读一个对象是否为 zepto 对象，这是通过判断这个对象是否为 zepto.Z 的实例来完成的，因此需要将 zepto.Z 和 Z 的 prototype 指向同一个对象。 isZ 方法会在 init 中用到，后面也会介绍。 参考 zepto源码分析-代码结构 zepto对象思想与源码分析 zepto设计和源码分析 zepto源码中关于zepto.Z.prototype = $.fn的问题 License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见：","categories":[],"tags":[]},{"title":"读Zepto源码之代码结构","slug":"读Zepto源码之代码结构的副本 4","date":"2018-05-09T12:50:33.000Z","updated":"2018-05-09T13:54:44.685Z","comments":true,"path":"2018/05/09/读Zepto源码之代码结构的副本 4/","link":"","permalink":"http://changguo.io/2018/05/09/读Zepto源码之代码结构的副本 4/","excerpt":"","text":"读Zepto源码之代码结构虽然最近工作中没有怎么用 zepto ，但是据说 zepto 的源码比较简单，而且网上的资料也比较多，所以我就挑了 zepto 下手，希望能为以后阅读其他框架的源码打下基础吧。 源码版本本文阅读的源码为 zepto1.2.0 阅读zepto之前需要了解 javascript 原型链和闭包的知识，推荐阅读王福朋的这篇文章:深入理解 Javascript 原型和闭包，写得很详细，也非常易于阅读。 GitBook《reading-zepto》 源码结构整体结构123456var Zepto = (function () &#123; ...&#125;)()window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto) 如果在编辑器中将 zepto 的源码折叠起来，看到的就跟上面的代码一样。 zepto 的核心是一个闭包，加载完毕后立即执行。然后暴露给全局变量 zepto ，如果 $ 没有定义，也将 $ 赋值为 Zepto 。 核心结构在这部分中，我们先不关注 zepto 的具体实现，只看核心的结构，因此我将zepto中的逻辑先移除，得出如下的核心结构： 123456789101112131415161718192021222324252627282930313233var zepto = &#123;&#125;, $function Z(doms) &#123; var len = doms.length for (var i = 0; i &lt; len; i++) &#123; this[i] = doms[i] &#125; this.length = doms.length&#125;zepto.Z = function(doms) &#123; return new Z(doms)&#125;zepto.init = function(doms) &#123; var doms = ['domObj1','domObj2','domObj3'] return zepto.Z(doms)&#125;$ = function() &#123; return zepto.init()&#125;$.fn = &#123; constructor: zepto.Z, method: function() &#123; return this &#125;&#125;zepto.Z.prototype = Z.prototype = $.fnreturn $ 在源码中，可以看出， $ 其实是一个函数，同时在 $ 身上又挂了很多属性和方法（这里体现在 $.fn 身上，其他的会在后续的文章中谈到）。 我们在使用 zepto 的时候，会用 $ 去获取 dom ，并且在这些 dom 对象身上都有 zepto 定义的各种各样的操作方法。 从上面的伪代码中，可以看到，$ 其实调用了 zepto.init() 方法，在 init 方法中，会获取到 dom 元素集合，然后将集合交由 zepto.Z() 方法处理，而 zepto.Z 方法返回的是函数 Z 的一个实例。 函数 Z 会将 doms 展开，变成实例的属性，key 为对应 domObj 的索引， 并且设置实例的 length 属性。 zepto.Z.prototype = Z.prototype = $.fn读到这里，你可能会有点疑惑，$ 最终返回的是 Z 函数的实例，但是 Z 函数明明没有 dom 的操作方法啊，这些操作方法都定义在 $.fn 身上，为什么 $ 可以调用这些方法呢？ 其实关键在于这句代码 Z.prototype = $.fn ，这句代码将 Z 的 prototype 指向 $.fn ，这样，Z 的实例就继承了 $.fn 的方法。 既然这样就已经让 Z 的实例继承了 $.fn 的方法，那 zepto.Z.prototype = $.fn 又是为什么呢？ 如果我们再看源码，会发现有这样的一个方法： 123zepto.isZ = function(object) &#123; return object instanceof zepto.Z&#125; 这个方法是用来判读一个对象是否为 zepto 对象，这是通过判断这个对象是否为 zepto.Z 的实例来完成的，因此需要将 zepto.Z 和 Z 的 prototype 指向同一个对象。 isZ 方法会在 init 中用到，后面也会介绍。 参考 zepto源码分析-代码结构 zepto对象思想与源码分析 zepto设计和源码分析 zepto源码中关于zepto.Z.prototype = $.fn的问题 License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见：","categories":[],"tags":[]},{"title":"读Zepto源码之代码结构","slug":"读Zepto源码之代码结构的副本 5","date":"2018-05-09T12:50:33.000Z","updated":"2018-05-09T13:54:44.685Z","comments":true,"path":"2018/05/09/读Zepto源码之代码结构的副本 5/","link":"","permalink":"http://changguo.io/2018/05/09/读Zepto源码之代码结构的副本 5/","excerpt":"","text":"读Zepto源码之代码结构虽然最近工作中没有怎么用 zepto ，但是据说 zepto 的源码比较简单，而且网上的资料也比较多，所以我就挑了 zepto 下手，希望能为以后阅读其他框架的源码打下基础吧。 源码版本本文阅读的源码为 zepto1.2.0 阅读zepto之前需要了解 javascript 原型链和闭包的知识，推荐阅读王福朋的这篇文章:深入理解 Javascript 原型和闭包，写得很详细，也非常易于阅读。 GitBook《reading-zepto》 源码结构整体结构123456var Zepto = (function () &#123; ...&#125;)()window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto) 如果在编辑器中将 zepto 的源码折叠起来，看到的就跟上面的代码一样。 zepto 的核心是一个闭包，加载完毕后立即执行。然后暴露给全局变量 zepto ，如果 $ 没有定义，也将 $ 赋值为 Zepto 。 核心结构在这部分中，我们先不关注 zepto 的具体实现，只看核心的结构，因此我将zepto中的逻辑先移除，得出如下的核心结构： 123456789101112131415161718192021222324252627282930313233var zepto = &#123;&#125;, $function Z(doms) &#123; var len = doms.length for (var i = 0; i &lt; len; i++) &#123; this[i] = doms[i] &#125; this.length = doms.length&#125;zepto.Z = function(doms) &#123; return new Z(doms)&#125;zepto.init = function(doms) &#123; var doms = ['domObj1','domObj2','domObj3'] return zepto.Z(doms)&#125;$ = function() &#123; return zepto.init()&#125;$.fn = &#123; constructor: zepto.Z, method: function() &#123; return this &#125;&#125;zepto.Z.prototype = Z.prototype = $.fnreturn $ 在源码中，可以看出， $ 其实是一个函数，同时在 $ 身上又挂了很多属性和方法（这里体现在 $.fn 身上，其他的会在后续的文章中谈到）。 我们在使用 zepto 的时候，会用 $ 去获取 dom ，并且在这些 dom 对象身上都有 zepto 定义的各种各样的操作方法。 从上面的伪代码中，可以看到，$ 其实调用了 zepto.init() 方法，在 init 方法中，会获取到 dom 元素集合，然后将集合交由 zepto.Z() 方法处理，而 zepto.Z 方法返回的是函数 Z 的一个实例。 函数 Z 会将 doms 展开，变成实例的属性，key 为对应 domObj 的索引， 并且设置实例的 length 属性。 zepto.Z.prototype = Z.prototype = $.fn读到这里，你可能会有点疑惑，$ 最终返回的是 Z 函数的实例，但是 Z 函数明明没有 dom 的操作方法啊，这些操作方法都定义在 $.fn 身上，为什么 $ 可以调用这些方法呢？ 其实关键在于这句代码 Z.prototype = $.fn ，这句代码将 Z 的 prototype 指向 $.fn ，这样，Z 的实例就继承了 $.fn 的方法。 既然这样就已经让 Z 的实例继承了 $.fn 的方法，那 zepto.Z.prototype = $.fn 又是为什么呢？ 如果我们再看源码，会发现有这样的一个方法： 123zepto.isZ = function(object) &#123; return object instanceof zepto.Z&#125; 这个方法是用来判读一个对象是否为 zepto 对象，这是通过判断这个对象是否为 zepto.Z 的实例来完成的，因此需要将 zepto.Z 和 Z 的 prototype 指向同一个对象。 isZ 方法会在 init 中用到，后面也会介绍。 参考 zepto源码分析-代码结构 zepto对象思想与源码分析 zepto设计和源码分析 zepto源码中关于zepto.Z.prototype = $.fn的问题 License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见：","categories":[],"tags":[]},{"title":"读Zepto源码之代码结构","slug":"读Zepto源码之代码结构的副本 6","date":"2018-05-09T12:50:33.000Z","updated":"2018-05-09T13:54:44.685Z","comments":true,"path":"2018/05/09/读Zepto源码之代码结构的副本 6/","link":"","permalink":"http://changguo.io/2018/05/09/读Zepto源码之代码结构的副本 6/","excerpt":"","text":"读Zepto源码之代码结构虽然最近工作中没有怎么用 zepto ，但是据说 zepto 的源码比较简单，而且网上的资料也比较多，所以我就挑了 zepto 下手，希望能为以后阅读其他框架的源码打下基础吧。 源码版本本文阅读的源码为 zepto1.2.0 阅读zepto之前需要了解 javascript 原型链和闭包的知识，推荐阅读王福朋的这篇文章:深入理解 Javascript 原型和闭包，写得很详细，也非常易于阅读。 GitBook《reading-zepto》 源码结构整体结构123456var Zepto = (function () &#123; ...&#125;)()window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto) 如果在编辑器中将 zepto 的源码折叠起来，看到的就跟上面的代码一样。 zepto 的核心是一个闭包，加载完毕后立即执行。然后暴露给全局变量 zepto ，如果 $ 没有定义，也将 $ 赋值为 Zepto 。 核心结构在这部分中，我们先不关注 zepto 的具体实现，只看核心的结构，因此我将zepto中的逻辑先移除，得出如下的核心结构： 123456789101112131415161718192021222324252627282930313233var zepto = &#123;&#125;, $function Z(doms) &#123; var len = doms.length for (var i = 0; i &lt; len; i++) &#123; this[i] = doms[i] &#125; this.length = doms.length&#125;zepto.Z = function(doms) &#123; return new Z(doms)&#125;zepto.init = function(doms) &#123; var doms = ['domObj1','domObj2','domObj3'] return zepto.Z(doms)&#125;$ = function() &#123; return zepto.init()&#125;$.fn = &#123; constructor: zepto.Z, method: function() &#123; return this &#125;&#125;zepto.Z.prototype = Z.prototype = $.fnreturn $ 在源码中，可以看出， $ 其实是一个函数，同时在 $ 身上又挂了很多属性和方法（这里体现在 $.fn 身上，其他的会在后续的文章中谈到）。 我们在使用 zepto 的时候，会用 $ 去获取 dom ，并且在这些 dom 对象身上都有 zepto 定义的各种各样的操作方法。 从上面的伪代码中，可以看到，$ 其实调用了 zepto.init() 方法，在 init 方法中，会获取到 dom 元素集合，然后将集合交由 zepto.Z() 方法处理，而 zepto.Z 方法返回的是函数 Z 的一个实例。 函数 Z 会将 doms 展开，变成实例的属性，key 为对应 domObj 的索引， 并且设置实例的 length 属性。 zepto.Z.prototype = Z.prototype = $.fn读到这里，你可能会有点疑惑，$ 最终返回的是 Z 函数的实例，但是 Z 函数明明没有 dom 的操作方法啊，这些操作方法都定义在 $.fn 身上，为什么 $ 可以调用这些方法呢？ 其实关键在于这句代码 Z.prototype = $.fn ，这句代码将 Z 的 prototype 指向 $.fn ，这样，Z 的实例就继承了 $.fn 的方法。 既然这样就已经让 Z 的实例继承了 $.fn 的方法，那 zepto.Z.prototype = $.fn 又是为什么呢？ 如果我们再看源码，会发现有这样的一个方法： 123zepto.isZ = function(object) &#123; return object instanceof zepto.Z&#125; 这个方法是用来判读一个对象是否为 zepto 对象，这是通过判断这个对象是否为 zepto.Z 的实例来完成的，因此需要将 zepto.Z 和 Z 的 prototype 指向同一个对象。 isZ 方法会在 init 中用到，后面也会介绍。 参考 zepto源码分析-代码结构 zepto对象思想与源码分析 zepto设计和源码分析 zepto源码中关于zepto.Z.prototype = $.fn的问题 License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见：","categories":[],"tags":[]},{"title":"读Zepto源码之代码结构","slug":"读Zepto源码之代码结构的副本 7","date":"2018-05-09T12:50:33.000Z","updated":"2018-05-09T13:54:44.685Z","comments":true,"path":"2018/05/09/读Zepto源码之代码结构的副本 7/","link":"","permalink":"http://changguo.io/2018/05/09/读Zepto源码之代码结构的副本 7/","excerpt":"","text":"读Zepto源码之代码结构虽然最近工作中没有怎么用 zepto ，但是据说 zepto 的源码比较简单，而且网上的资料也比较多，所以我就挑了 zepto 下手，希望能为以后阅读其他框架的源码打下基础吧。 源码版本本文阅读的源码为 zepto1.2.0 阅读zepto之前需要了解 javascript 原型链和闭包的知识，推荐阅读王福朋的这篇文章:深入理解 Javascript 原型和闭包，写得很详细，也非常易于阅读。 GitBook《reading-zepto》 源码结构整体结构123456var Zepto = (function () &#123; ...&#125;)()window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto) 如果在编辑器中将 zepto 的源码折叠起来，看到的就跟上面的代码一样。 zepto 的核心是一个闭包，加载完毕后立即执行。然后暴露给全局变量 zepto ，如果 $ 没有定义，也将 $ 赋值为 Zepto 。 核心结构在这部分中，我们先不关注 zepto 的具体实现，只看核心的结构，因此我将zepto中的逻辑先移除，得出如下的核心结构： 123456789101112131415161718192021222324252627282930313233var zepto = &#123;&#125;, $function Z(doms) &#123; var len = doms.length for (var i = 0; i &lt; len; i++) &#123; this[i] = doms[i] &#125; this.length = doms.length&#125;zepto.Z = function(doms) &#123; return new Z(doms)&#125;zepto.init = function(doms) &#123; var doms = ['domObj1','domObj2','domObj3'] return zepto.Z(doms)&#125;$ = function() &#123; return zepto.init()&#125;$.fn = &#123; constructor: zepto.Z, method: function() &#123; return this &#125;&#125;zepto.Z.prototype = Z.prototype = $.fnreturn $ 在源码中，可以看出， $ 其实是一个函数，同时在 $ 身上又挂了很多属性和方法（这里体现在 $.fn 身上，其他的会在后续的文章中谈到）。 我们在使用 zepto 的时候，会用 $ 去获取 dom ，并且在这些 dom 对象身上都有 zepto 定义的各种各样的操作方法。 从上面的伪代码中，可以看到，$ 其实调用了 zepto.init() 方法，在 init 方法中，会获取到 dom 元素集合，然后将集合交由 zepto.Z() 方法处理，而 zepto.Z 方法返回的是函数 Z 的一个实例。 函数 Z 会将 doms 展开，变成实例的属性，key 为对应 domObj 的索引， 并且设置实例的 length 属性。 zepto.Z.prototype = Z.prototype = $.fn读到这里，你可能会有点疑惑，$ 最终返回的是 Z 函数的实例，但是 Z 函数明明没有 dom 的操作方法啊，这些操作方法都定义在 $.fn 身上，为什么 $ 可以调用这些方法呢？ 其实关键在于这句代码 Z.prototype = $.fn ，这句代码将 Z 的 prototype 指向 $.fn ，这样，Z 的实例就继承了 $.fn 的方法。 既然这样就已经让 Z 的实例继承了 $.fn 的方法，那 zepto.Z.prototype = $.fn 又是为什么呢？ 如果我们再看源码，会发现有这样的一个方法： 123zepto.isZ = function(object) &#123; return object instanceof zepto.Z&#125; 这个方法是用来判读一个对象是否为 zepto 对象，这是通过判断这个对象是否为 zepto.Z 的实例来完成的，因此需要将 zepto.Z 和 Z 的 prototype 指向同一个对象。 isZ 方法会在 init 中用到，后面也会介绍。 参考 zepto源码分析-代码结构 zepto对象思想与源码分析 zepto设计和源码分析 zepto源码中关于zepto.Z.prototype = $.fn的问题 License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见：","categories":[],"tags":[]},{"title":"读Zepto源码之代码结构","slug":"读Zepto源码之代码结构的副本","date":"2018-05-09T12:50:33.000Z","updated":"2018-05-09T13:54:44.685Z","comments":true,"path":"2018/05/09/读Zepto源码之代码结构的副本/","link":"","permalink":"http://changguo.io/2018/05/09/读Zepto源码之代码结构的副本/","excerpt":"","text":"读Zepto源码之代码结构虽然最近工作中没有怎么用 zepto ，但是据说 zepto 的源码比较简单，而且网上的资料也比较多，所以我就挑了 zepto 下手，希望能为以后阅读其他框架的源码打下基础吧。 源码版本本文阅读的源码为 zepto1.2.0 阅读zepto之前需要了解 javascript 原型链和闭包的知识，推荐阅读王福朋的这篇文章:深入理解 Javascript 原型和闭包，写得很详细，也非常易于阅读。 GitBook《reading-zepto》 源码结构整体结构123456var Zepto = (function () &#123; ...&#125;)()window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto) 如果在编辑器中将 zepto 的源码折叠起来，看到的就跟上面的代码一样。 zepto 的核心是一个闭包，加载完毕后立即执行。然后暴露给全局变量 zepto ，如果 $ 没有定义，也将 $ 赋值为 Zepto 。 核心结构在这部分中，我们先不关注 zepto 的具体实现，只看核心的结构，因此我将zepto中的逻辑先移除，得出如下的核心结构： 123456789101112131415161718192021222324252627282930313233var zepto = &#123;&#125;, $function Z(doms) &#123; var len = doms.length for (var i = 0; i &lt; len; i++) &#123; this[i] = doms[i] &#125; this.length = doms.length&#125;zepto.Z = function(doms) &#123; return new Z(doms)&#125;zepto.init = function(doms) &#123; var doms = ['domObj1','domObj2','domObj3'] return zepto.Z(doms)&#125;$ = function() &#123; return zepto.init()&#125;$.fn = &#123; constructor: zepto.Z, method: function() &#123; return this &#125;&#125;zepto.Z.prototype = Z.prototype = $.fnreturn $ 在源码中，可以看出， $ 其实是一个函数，同时在 $ 身上又挂了很多属性和方法（这里体现在 $.fn 身上，其他的会在后续的文章中谈到）。 我们在使用 zepto 的时候，会用 $ 去获取 dom ，并且在这些 dom 对象身上都有 zepto 定义的各种各样的操作方法。 从上面的伪代码中，可以看到，$ 其实调用了 zepto.init() 方法，在 init 方法中，会获取到 dom 元素集合，然后将集合交由 zepto.Z() 方法处理，而 zepto.Z 方法返回的是函数 Z 的一个实例。 函数 Z 会将 doms 展开，变成实例的属性，key 为对应 domObj 的索引， 并且设置实例的 length 属性。 zepto.Z.prototype = Z.prototype = $.fn读到这里，你可能会有点疑惑，$ 最终返回的是 Z 函数的实例，但是 Z 函数明明没有 dom 的操作方法啊，这些操作方法都定义在 $.fn 身上，为什么 $ 可以调用这些方法呢？ 其实关键在于这句代码 Z.prototype = $.fn ，这句代码将 Z 的 prototype 指向 $.fn ，这样，Z 的实例就继承了 $.fn 的方法。 既然这样就已经让 Z 的实例继承了 $.fn 的方法，那 zepto.Z.prototype = $.fn 又是为什么呢？ 如果我们再看源码，会发现有这样的一个方法： 123zepto.isZ = function(object) &#123; return object instanceof zepto.Z&#125; 这个方法是用来判读一个对象是否为 zepto 对象，这是通过判断这个对象是否为 zepto.Z 的实例来完成的，因此需要将 zepto.Z 和 Z 的 prototype 指向同一个对象。 isZ 方法会在 init 中用到，后面也会介绍。 参考 zepto源码分析-代码结构 zepto对象思想与源码分析 zepto设计和源码分析 zepto源码中关于zepto.Z.prototype = $.fn的问题 License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见：","categories":[],"tags":[]},{"title":"读Zepto源码之代码结构","slug":"读Zepto源码之代码结构的副本 2","date":"2018-05-09T12:50:33.000Z","updated":"2018-05-09T13:54:44.685Z","comments":true,"path":"2018/05/09/读Zepto源码之代码结构的副本 2/","link":"","permalink":"http://changguo.io/2018/05/09/读Zepto源码之代码结构的副本 2/","excerpt":"","text":"读Zepto源码之代码结构虽然最近工作中没有怎么用 zepto ，但是据说 zepto 的源码比较简单，而且网上的资料也比较多，所以我就挑了 zepto 下手，希望能为以后阅读其他框架的源码打下基础吧。 源码版本本文阅读的源码为 zepto1.2.0 阅读zepto之前需要了解 javascript 原型链和闭包的知识，推荐阅读王福朋的这篇文章:深入理解 Javascript 原型和闭包，写得很详细，也非常易于阅读。 GitBook《reading-zepto》 源码结构整体结构123456var Zepto = (function () &#123; ...&#125;)()window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto) 如果在编辑器中将 zepto 的源码折叠起来，看到的就跟上面的代码一样。 zepto 的核心是一个闭包，加载完毕后立即执行。然后暴露给全局变量 zepto ，如果 $ 没有定义，也将 $ 赋值为 Zepto 。 核心结构在这部分中，我们先不关注 zepto 的具体实现，只看核心的结构，因此我将zepto中的逻辑先移除，得出如下的核心结构： 123456789101112131415161718192021222324252627282930313233var zepto = &#123;&#125;, $function Z(doms) &#123; var len = doms.length for (var i = 0; i &lt; len; i++) &#123; this[i] = doms[i] &#125; this.length = doms.length&#125;zepto.Z = function(doms) &#123; return new Z(doms)&#125;zepto.init = function(doms) &#123; var doms = ['domObj1','domObj2','domObj3'] return zepto.Z(doms)&#125;$ = function() &#123; return zepto.init()&#125;$.fn = &#123; constructor: zepto.Z, method: function() &#123; return this &#125;&#125;zepto.Z.prototype = Z.prototype = $.fnreturn $ 在源码中，可以看出， $ 其实是一个函数，同时在 $ 身上又挂了很多属性和方法（这里体现在 $.fn 身上，其他的会在后续的文章中谈到）。 我们在使用 zepto 的时候，会用 $ 去获取 dom ，并且在这些 dom 对象身上都有 zepto 定义的各种各样的操作方法。 从上面的伪代码中，可以看到，$ 其实调用了 zepto.init() 方法，在 init 方法中，会获取到 dom 元素集合，然后将集合交由 zepto.Z() 方法处理，而 zepto.Z 方法返回的是函数 Z 的一个实例。 函数 Z 会将 doms 展开，变成实例的属性，key 为对应 domObj 的索引， 并且设置实例的 length 属性。 zepto.Z.prototype = Z.prototype = $.fn读到这里，你可能会有点疑惑，$ 最终返回的是 Z 函数的实例，但是 Z 函数明明没有 dom 的操作方法啊，这些操作方法都定义在 $.fn 身上，为什么 $ 可以调用这些方法呢？ 其实关键在于这句代码 Z.prototype = $.fn ，这句代码将 Z 的 prototype 指向 $.fn ，这样，Z 的实例就继承了 $.fn 的方法。 既然这样就已经让 Z 的实例继承了 $.fn 的方法，那 zepto.Z.prototype = $.fn 又是为什么呢？ 如果我们再看源码，会发现有这样的一个方法： 123zepto.isZ = function(object) &#123; return object instanceof zepto.Z&#125; 这个方法是用来判读一个对象是否为 zepto 对象，这是通过判断这个对象是否为 zepto.Z 的实例来完成的，因此需要将 zepto.Z 和 Z 的 prototype 指向同一个对象。 isZ 方法会在 init 中用到，后面也会介绍。 参考 zepto源码分析-代码结构 zepto对象思想与源码分析 zepto设计和源码分析 zepto源码中关于zepto.Z.prototype = $.fn的问题 License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见：","categories":[],"tags":[]},{"title":"读zepto源码之工具函数","slug":"读Zepto源码之工具函数","date":"2018-04-09T12:50:33.000Z","updated":"2018-05-09T13:59:13.966Z","comments":true,"path":"2018/04/09/读Zepto源码之工具函数/","link":"","permalink":"http://changguo.io/2018/04/09/读Zepto源码之工具函数/","excerpt":"","text":"读zepto源码之工具函数Zepto 提供了丰富的工具函数，下面来一一解读。 源码版本本文阅读的源码为 zepto1.2.0 GitBook《reading-zepto》 $.extend$.extend 方法可以用来扩展目标对象的属性。目标对象的同名属性会被源对象的属性覆盖。 $.extend 其实调用的是内部方法 extend， 所以我们先看看内部方法 extend 的具体实现。 12345678910function extend(target, source, deep) &#123; for (key in source) // 遍历源对象的属性值 if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123; // 如果为深度复制，并且源对象的属性值为纯粹对象或者数组 if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) // 如果为纯粹对象 target[key] = &#123;&#125; // 如果源对象的属性值为纯粹对象，并且目标对象对应的属性值不为纯粹对象，则将目标对象对应的属性值置为空对象 if (isArray(source[key]) &amp;&amp; !isArray(target[key])) // 如果源对象的属性值为数组，并且目标对象对应的属性值不为数组，则将目标对象对应的属性值置为空数组 target[key] = [] extend(target[key], source[key], deep) // 递归调用extend函数 &#125; else if (source[key] !== undefined) target[key] = source[key] // 不对undefined值进行复制 &#125; extend 的第一个参数 taget 为目标对象， source 为源对象， deep 表示是否为深度复制。当 deep 为 true 时为深度复制， false 时为浅复制。 extend 函数用 for···in 对 source 的属性进行遍历 如果 deep 为 false 时，只进行浅复制，将 source 中不为 undefined 的值赋值到 target 对应的属性中（注意，这里用的是 !==，不是 != ，所以只排除严格为 undefined 的值，不包含 null ）。如果 source 对应的属性值为对象或者数组，会保持该对象或数组的引用。 如果 deep 为 true ，并且 source 的属性值为纯粹对象或者数组时 3.1. 如果 source 的属性为纯粹对象，并且 target 对应的属性不为纯粹对象时，将 target 的对应属性设置为空对象 3.2. 如果 source 的属性为数组，并且 target 对应属性不为数组时，将 target 的对应属性设置为空数组 3.3. 将 source 和 target 对应的属性及 deep 作为参数，递归调用 extend 函数，以实现深度复制。 现在，再看看 $.extend 的具体实现 123456789$.extend = function(target) &#123; var deep, args = slice.call(arguments, 1) if (typeof target == 'boolean') &#123; deep = target target = args.shift() &#125; args.forEach(function(arg) &#123; extend(target, arg, deep) &#125;) return target &#125; 在说原理之前，先来看看 $.extend 的调用方式，调用方式如下： 123$.extend(target, [source, [source2, ...]]) 或$.extend(true, target, [source, ...]) 在 $.extend 中，如果不需要深度复制，第一个参数可以是目标对象 target, 后面可以有多个 source 源对象。如果需要深度复制，第一个参数为 deep ，第二个参数为 target ，为目标对象，后面可以有多个 source 源对象。 $.extend 函数的参数设计得很优雅，不需要深度复制时，可以不用显式地将 deep 置为 false。这是如何做到的呢？ 在 $.extend 函数中，定义了一个数组 args，用来接受除第一个参数外的所有参数。 然后判断第一个参数 target 是否为布尔值，如果为布尔值，表示第一个参数为 deep ，那么第二个才为目标对象，因此需要重新为 target 赋值为 args.shift() 。 最后就比较简单了，循环源对象数组 args， 分别调用 extend 方法，实现对目标对象的扩展。 $.each$.each 用来遍历数组或者对象，源码如下： 123456789101112$.each = function(elements, callback) &#123; var i, key if (likeArray(elements)) &#123; // 类数组 for (i = 0; i &lt; elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements &#125; else &#123; // 对象 for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements &#125; return elements &#125; 先来看看调用方式：$.each(collection, function(index, item){ ... }) $.each 接收两个参数，第一个参数 elements 为需要遍历的数组或者对象，第二个 callback 为回调函数。 如果 elements 为数组，用 for 循环，调用 callback ，并且将数组索引 index 和元素值 item 传给回调函数作为参数；如果为对象，用 for···in 遍历属性值，并且将属性 key 及属性值传给回调函数作为参数。 注意回调函数调用了 call 方法，call 的第一个参数为当前元素值或当前属性值，所以回调函数的上下文变成了当前元素值或属性值，也就是说回调函数中的 this 指向的是 item 。这在dom集合的遍历中相当有用。 在遍历的时候，还对回调函数的返回值进行判断，如果回调函数返回 false （if (callback.call(elements[i], i, elements[i]) === false)） ，立即中断遍历。 $.each 调用结束后，会将遍历的数组或对象（ elements ）返回。 $.map可以遍历数组（类数组）或对象中的元素，根据回调函数的返回值，将返回值组成一个新的数组，并将该数组扁平化后返回，会将 null 及 undefined 排除。 123456789101112131415$.map = function(elements, callback) &#123; var value, values = [], i, key if (likeArray(elements)) for (i = 0; i &lt; elements.length; i++) &#123; value = callback(elements[i], i) if (value != null) values.push(value) &#125; else for (key in elements) &#123; value = callback(elements[key], key) if (value != null) values.push(value) &#125; return flatten(values) &#125; 先来看看调用方式： $.map(collection, function(item, index){ ... }) elements 为类数组或者对象。callback 为回调函数。当为类数组时，用 for 循环，当为对象时，用 for···in 循环。并且将对应的元素（属性值）及索引（属性名）传递给回调函数，如果回调函数的返回值不为 null 或者 undefined ，则将返回值存入新数组中，最后将新数组扁平化后返回。 $.camelCase该方法是将字符串转换成驼峰式的字符串 1$.camelCase = camelize $.camelCase 调用的是内部方法 camelize ,该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述，本篇文章就不再展开。 $.contains用来检查给定的父节点中是否包含有给定的子节点，源码如下： 123456789$.contains = document.documentElement.contains ? function(parent, node) &#123; return parent !== node &amp;&amp; parent.contains(node) &#125; : function(parent, node) &#123; while (node &amp;&amp; (node = node.parentNode)) if (node === parent) return true return false &#125; 先来看看调用：$.contains(parent, node) 参数 parent 为父子点，node 为子节点。 $.contains 的主体是一个三元表达式，返回的是一个匿名函数。三元表达式的条件是 document.documentElement.contains， 用来检测浏览器是否支持 contains 方法，如果支持，则直接调用 contains 方法，并且将 parent 和 node 为同一个元素的情况排除。 否则，返回另一外匿名函数。该函数会一直向上寻找 node 元素的父元素，如果能找到跟 parent 相等的父元素，则返回 true， 否则返回 false $.grep该函数其实就是数组的 filter 函数 123$.grep = function(elements, callback) &#123; return filter.call(elements, callback) &#125; 从源码中也可以看出，$.grep 调用的就是数组方法 filter $.inArray返回指定元素在数组中的索引值 123$.inArray = function(elem, array, i) &#123; return emptyArray.indexOf.call(array, elem, i) &#125; 先来看看调用 $.inArray(element, array, [fromIndex]) 第一个参数 element 为指定的元素，第二个参数为 array 为数组， 第三个参数 fromIndex 为可选参数，表示从哪个索引值开始向后查找。 $.inArray 其实调用的是数组的 indexOf 方法，所以传递的参数跟 indexOf 方法一致。 $.isArray判断是否为数组 1$.isArray = isArray $.isArray 调用的是内部方法 isArray ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isFunction判读是否为函数 1$.isFunction = isFunction $.isFunction 调用的是内部方法 isFunction ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isNumeric是否为数值 12345678910$.isNumeric = function(val) &#123; var num = Number(val), // 将参数转换为Number类型 type = typeof val return val != null &amp;&amp; type != 'boolean' &amp;&amp; (type != 'string' || val.length) &amp;&amp; !isNaN(num) &amp;&amp; isFinite(num) || false &#125; 判断是否为数值，需要满足以下条件 不为 null 不为布尔值 不为NaN(当传进来的参数不为数值或如&#39;123&#39;这样形式的字符串时，都会转换成NaN) 为有限数值 当传进来的参数为字符串的形式，如&#39;123&#39; 时，会用到下面这个条件来确保字符串为数字的形式，而不是如 123abc 这样的形式。(type != &#39;string&#39; || val.length) &amp;&amp; !isNaN(num) 。这个条件的包含逻辑如下：如果为字符串类型，并且为字符串的长度大于零，并且转换成数组后的结果不为NaN，则断定为数值。（因为 Number(&#39;&#39;) 的值为 0） $.isPlainObject是否为纯粹对象，即以 {} 常量或 new Object() 创建的对象 1$.isPlainObject = isPlainObject $.isPlainObject 调用的是内部方法isPlainObject ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isWindow是否为浏览器的 window 对象 1$.isWindow = isWindow $.isWindow 调用的是内部方法 isWindow ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.noop空函数 1$.noop = function() &#123;&#125; 这个在需要传递回调函数作为参数，但是又不想在回调函数中做任何事情的时候会非常有用，这时，只需要传递一个空函数即可。 $.parseJSON将标准JSON格式的字符串解释成JSON 1if (window.JSON) $.parseJSON = JSON.parse 其实就是调用原生的 JSON.parse， 并且在浏览器不支持的情况下，zepto 还不提供这个方法。 $.trim删除字符串头尾的空格 123$.trim = function(str) &#123; return str == null ? \"\" : String.prototype.trim.call(str)&#125; 如果参数为 null 或者 undefined ，则直接返回空字符串，否则调用字符串原生的 trim 方法去除头尾的空格。 $.type类型检测 1$.type = type $.type 调用的是内部方法 type ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 能检测的类型有 &quot;Boolean Number String Function Array Date RegExp Object Error&quot; 系列文章 读Zepto源码之代码结构 读 Zepto 源码之内部方法 参考 Zepto中文文档 Node.contains() Array.prototype.indexOf() String.prototype.trim() License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见： 作者：对角另一面","categories":[],"tags":[]},{"title":"读zepto源码之工具函数","slug":"读Zepto源码之工具函数的副本 2","date":"2018-04-09T12:50:33.000Z","updated":"2018-05-09T13:59:13.966Z","comments":true,"path":"2018/04/09/读Zepto源码之工具函数的副本 2/","link":"","permalink":"http://changguo.io/2018/04/09/读Zepto源码之工具函数的副本 2/","excerpt":"","text":"读zepto源码之工具函数Zepto 提供了丰富的工具函数，下面来一一解读。 源码版本本文阅读的源码为 zepto1.2.0 GitBook《reading-zepto》 $.extend$.extend 方法可以用来扩展目标对象的属性。目标对象的同名属性会被源对象的属性覆盖。 $.extend 其实调用的是内部方法 extend， 所以我们先看看内部方法 extend 的具体实现。 12345678910function extend(target, source, deep) &#123; for (key in source) // 遍历源对象的属性值 if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123; // 如果为深度复制，并且源对象的属性值为纯粹对象或者数组 if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) // 如果为纯粹对象 target[key] = &#123;&#125; // 如果源对象的属性值为纯粹对象，并且目标对象对应的属性值不为纯粹对象，则将目标对象对应的属性值置为空对象 if (isArray(source[key]) &amp;&amp; !isArray(target[key])) // 如果源对象的属性值为数组，并且目标对象对应的属性值不为数组，则将目标对象对应的属性值置为空数组 target[key] = [] extend(target[key], source[key], deep) // 递归调用extend函数 &#125; else if (source[key] !== undefined) target[key] = source[key] // 不对undefined值进行复制 &#125; extend 的第一个参数 taget 为目标对象， source 为源对象， deep 表示是否为深度复制。当 deep 为 true 时为深度复制， false 时为浅复制。 extend 函数用 for···in 对 source 的属性进行遍历 如果 deep 为 false 时，只进行浅复制，将 source 中不为 undefined 的值赋值到 target 对应的属性中（注意，这里用的是 !==，不是 != ，所以只排除严格为 undefined 的值，不包含 null ）。如果 source 对应的属性值为对象或者数组，会保持该对象或数组的引用。 如果 deep 为 true ，并且 source 的属性值为纯粹对象或者数组时 3.1. 如果 source 的属性为纯粹对象，并且 target 对应的属性不为纯粹对象时，将 target 的对应属性设置为空对象 3.2. 如果 source 的属性为数组，并且 target 对应属性不为数组时，将 target 的对应属性设置为空数组 3.3. 将 source 和 target 对应的属性及 deep 作为参数，递归调用 extend 函数，以实现深度复制。 现在，再看看 $.extend 的具体实现 123456789$.extend = function(target) &#123; var deep, args = slice.call(arguments, 1) if (typeof target == 'boolean') &#123; deep = target target = args.shift() &#125; args.forEach(function(arg) &#123; extend(target, arg, deep) &#125;) return target &#125; 在说原理之前，先来看看 $.extend 的调用方式，调用方式如下： 123$.extend(target, [source, [source2, ...]]) 或$.extend(true, target, [source, ...]) 在 $.extend 中，如果不需要深度复制，第一个参数可以是目标对象 target, 后面可以有多个 source 源对象。如果需要深度复制，第一个参数为 deep ，第二个参数为 target ，为目标对象，后面可以有多个 source 源对象。 $.extend 函数的参数设计得很优雅，不需要深度复制时，可以不用显式地将 deep 置为 false。这是如何做到的呢？ 在 $.extend 函数中，定义了一个数组 args，用来接受除第一个参数外的所有参数。 然后判断第一个参数 target 是否为布尔值，如果为布尔值，表示第一个参数为 deep ，那么第二个才为目标对象，因此需要重新为 target 赋值为 args.shift() 。 最后就比较简单了，循环源对象数组 args， 分别调用 extend 方法，实现对目标对象的扩展。 $.each$.each 用来遍历数组或者对象，源码如下： 123456789101112$.each = function(elements, callback) &#123; var i, key if (likeArray(elements)) &#123; // 类数组 for (i = 0; i &lt; elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements &#125; else &#123; // 对象 for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements &#125; return elements &#125; 先来看看调用方式：$.each(collection, function(index, item){ ... }) $.each 接收两个参数，第一个参数 elements 为需要遍历的数组或者对象，第二个 callback 为回调函数。 如果 elements 为数组，用 for 循环，调用 callback ，并且将数组索引 index 和元素值 item 传给回调函数作为参数；如果为对象，用 for···in 遍历属性值，并且将属性 key 及属性值传给回调函数作为参数。 注意回调函数调用了 call 方法，call 的第一个参数为当前元素值或当前属性值，所以回调函数的上下文变成了当前元素值或属性值，也就是说回调函数中的 this 指向的是 item 。这在dom集合的遍历中相当有用。 在遍历的时候，还对回调函数的返回值进行判断，如果回调函数返回 false （if (callback.call(elements[i], i, elements[i]) === false)） ，立即中断遍历。 $.each 调用结束后，会将遍历的数组或对象（ elements ）返回。 $.map可以遍历数组（类数组）或对象中的元素，根据回调函数的返回值，将返回值组成一个新的数组，并将该数组扁平化后返回，会将 null 及 undefined 排除。 123456789101112131415$.map = function(elements, callback) &#123; var value, values = [], i, key if (likeArray(elements)) for (i = 0; i &lt; elements.length; i++) &#123; value = callback(elements[i], i) if (value != null) values.push(value) &#125; else for (key in elements) &#123; value = callback(elements[key], key) if (value != null) values.push(value) &#125; return flatten(values) &#125; 先来看看调用方式： $.map(collection, function(item, index){ ... }) elements 为类数组或者对象。callback 为回调函数。当为类数组时，用 for 循环，当为对象时，用 for···in 循环。并且将对应的元素（属性值）及索引（属性名）传递给回调函数，如果回调函数的返回值不为 null 或者 undefined ，则将返回值存入新数组中，最后将新数组扁平化后返回。 $.camelCase该方法是将字符串转换成驼峰式的字符串 1$.camelCase = camelize $.camelCase 调用的是内部方法 camelize ,该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述，本篇文章就不再展开。 $.contains用来检查给定的父节点中是否包含有给定的子节点，源码如下： 123456789$.contains = document.documentElement.contains ? function(parent, node) &#123; return parent !== node &amp;&amp; parent.contains(node) &#125; : function(parent, node) &#123; while (node &amp;&amp; (node = node.parentNode)) if (node === parent) return true return false &#125; 先来看看调用：$.contains(parent, node) 参数 parent 为父子点，node 为子节点。 $.contains 的主体是一个三元表达式，返回的是一个匿名函数。三元表达式的条件是 document.documentElement.contains， 用来检测浏览器是否支持 contains 方法，如果支持，则直接调用 contains 方法，并且将 parent 和 node 为同一个元素的情况排除。 否则，返回另一外匿名函数。该函数会一直向上寻找 node 元素的父元素，如果能找到跟 parent 相等的父元素，则返回 true， 否则返回 false $.grep该函数其实就是数组的 filter 函数 123$.grep = function(elements, callback) &#123; return filter.call(elements, callback) &#125; 从源码中也可以看出，$.grep 调用的就是数组方法 filter $.inArray返回指定元素在数组中的索引值 123$.inArray = function(elem, array, i) &#123; return emptyArray.indexOf.call(array, elem, i) &#125; 先来看看调用 $.inArray(element, array, [fromIndex]) 第一个参数 element 为指定的元素，第二个参数为 array 为数组， 第三个参数 fromIndex 为可选参数，表示从哪个索引值开始向后查找。 $.inArray 其实调用的是数组的 indexOf 方法，所以传递的参数跟 indexOf 方法一致。 $.isArray判断是否为数组 1$.isArray = isArray $.isArray 调用的是内部方法 isArray ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isFunction判读是否为函数 1$.isFunction = isFunction $.isFunction 调用的是内部方法 isFunction ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isNumeric是否为数值 12345678910$.isNumeric = function(val) &#123; var num = Number(val), // 将参数转换为Number类型 type = typeof val return val != null &amp;&amp; type != 'boolean' &amp;&amp; (type != 'string' || val.length) &amp;&amp; !isNaN(num) &amp;&amp; isFinite(num) || false &#125; 判断是否为数值，需要满足以下条件 不为 null 不为布尔值 不为NaN(当传进来的参数不为数值或如&#39;123&#39;这样形式的字符串时，都会转换成NaN) 为有限数值 当传进来的参数为字符串的形式，如&#39;123&#39; 时，会用到下面这个条件来确保字符串为数字的形式，而不是如 123abc 这样的形式。(type != &#39;string&#39; || val.length) &amp;&amp; !isNaN(num) 。这个条件的包含逻辑如下：如果为字符串类型，并且为字符串的长度大于零，并且转换成数组后的结果不为NaN，则断定为数值。（因为 Number(&#39;&#39;) 的值为 0） $.isPlainObject是否为纯粹对象，即以 {} 常量或 new Object() 创建的对象 1$.isPlainObject = isPlainObject $.isPlainObject 调用的是内部方法isPlainObject ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isWindow是否为浏览器的 window 对象 1$.isWindow = isWindow $.isWindow 调用的是内部方法 isWindow ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.noop空函数 1$.noop = function() &#123;&#125; 这个在需要传递回调函数作为参数，但是又不想在回调函数中做任何事情的时候会非常有用，这时，只需要传递一个空函数即可。 $.parseJSON将标准JSON格式的字符串解释成JSON 1if (window.JSON) $.parseJSON = JSON.parse 其实就是调用原生的 JSON.parse， 并且在浏览器不支持的情况下，zepto 还不提供这个方法。 $.trim删除字符串头尾的空格 123$.trim = function(str) &#123; return str == null ? \"\" : String.prototype.trim.call(str)&#125; 如果参数为 null 或者 undefined ，则直接返回空字符串，否则调用字符串原生的 trim 方法去除头尾的空格。 $.type类型检测 1$.type = type $.type 调用的是内部方法 type ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 能检测的类型有 &quot;Boolean Number String Function Array Date RegExp Object Error&quot; 系列文章 读Zepto源码之代码结构 读 Zepto 源码之内部方法 参考 Zepto中文文档 Node.contains() Array.prototype.indexOf() String.prototype.trim() License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见： 作者：对角另一面","categories":[],"tags":[]},{"title":"读zepto源码之工具函数","slug":"读Zepto源码之工具函数的副本 3","date":"2018-04-09T12:50:33.000Z","updated":"2018-05-09T13:59:13.966Z","comments":true,"path":"2018/04/09/读Zepto源码之工具函数的副本 3/","link":"","permalink":"http://changguo.io/2018/04/09/读Zepto源码之工具函数的副本 3/","excerpt":"","text":"读zepto源码之工具函数Zepto 提供了丰富的工具函数，下面来一一解读。 源码版本本文阅读的源码为 zepto1.2.0 GitBook《reading-zepto》 $.extend$.extend 方法可以用来扩展目标对象的属性。目标对象的同名属性会被源对象的属性覆盖。 $.extend 其实调用的是内部方法 extend， 所以我们先看看内部方法 extend 的具体实现。 12345678910function extend(target, source, deep) &#123; for (key in source) // 遍历源对象的属性值 if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123; // 如果为深度复制，并且源对象的属性值为纯粹对象或者数组 if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) // 如果为纯粹对象 target[key] = &#123;&#125; // 如果源对象的属性值为纯粹对象，并且目标对象对应的属性值不为纯粹对象，则将目标对象对应的属性值置为空对象 if (isArray(source[key]) &amp;&amp; !isArray(target[key])) // 如果源对象的属性值为数组，并且目标对象对应的属性值不为数组，则将目标对象对应的属性值置为空数组 target[key] = [] extend(target[key], source[key], deep) // 递归调用extend函数 &#125; else if (source[key] !== undefined) target[key] = source[key] // 不对undefined值进行复制 &#125; extend 的第一个参数 taget 为目标对象， source 为源对象， deep 表示是否为深度复制。当 deep 为 true 时为深度复制， false 时为浅复制。 extend 函数用 for···in 对 source 的属性进行遍历 如果 deep 为 false 时，只进行浅复制，将 source 中不为 undefined 的值赋值到 target 对应的属性中（注意，这里用的是 !==，不是 != ，所以只排除严格为 undefined 的值，不包含 null ）。如果 source 对应的属性值为对象或者数组，会保持该对象或数组的引用。 如果 deep 为 true ，并且 source 的属性值为纯粹对象或者数组时 3.1. 如果 source 的属性为纯粹对象，并且 target 对应的属性不为纯粹对象时，将 target 的对应属性设置为空对象 3.2. 如果 source 的属性为数组，并且 target 对应属性不为数组时，将 target 的对应属性设置为空数组 3.3. 将 source 和 target 对应的属性及 deep 作为参数，递归调用 extend 函数，以实现深度复制。 现在，再看看 $.extend 的具体实现 123456789$.extend = function(target) &#123; var deep, args = slice.call(arguments, 1) if (typeof target == 'boolean') &#123; deep = target target = args.shift() &#125; args.forEach(function(arg) &#123; extend(target, arg, deep) &#125;) return target &#125; 在说原理之前，先来看看 $.extend 的调用方式，调用方式如下： 123$.extend(target, [source, [source2, ...]]) 或$.extend(true, target, [source, ...]) 在 $.extend 中，如果不需要深度复制，第一个参数可以是目标对象 target, 后面可以有多个 source 源对象。如果需要深度复制，第一个参数为 deep ，第二个参数为 target ，为目标对象，后面可以有多个 source 源对象。 $.extend 函数的参数设计得很优雅，不需要深度复制时，可以不用显式地将 deep 置为 false。这是如何做到的呢？ 在 $.extend 函数中，定义了一个数组 args，用来接受除第一个参数外的所有参数。 然后判断第一个参数 target 是否为布尔值，如果为布尔值，表示第一个参数为 deep ，那么第二个才为目标对象，因此需要重新为 target 赋值为 args.shift() 。 最后就比较简单了，循环源对象数组 args， 分别调用 extend 方法，实现对目标对象的扩展。 $.each$.each 用来遍历数组或者对象，源码如下： 123456789101112$.each = function(elements, callback) &#123; var i, key if (likeArray(elements)) &#123; // 类数组 for (i = 0; i &lt; elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements &#125; else &#123; // 对象 for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements &#125; return elements &#125; 先来看看调用方式：$.each(collection, function(index, item){ ... }) $.each 接收两个参数，第一个参数 elements 为需要遍历的数组或者对象，第二个 callback 为回调函数。 如果 elements 为数组，用 for 循环，调用 callback ，并且将数组索引 index 和元素值 item 传给回调函数作为参数；如果为对象，用 for···in 遍历属性值，并且将属性 key 及属性值传给回调函数作为参数。 注意回调函数调用了 call 方法，call 的第一个参数为当前元素值或当前属性值，所以回调函数的上下文变成了当前元素值或属性值，也就是说回调函数中的 this 指向的是 item 。这在dom集合的遍历中相当有用。 在遍历的时候，还对回调函数的返回值进行判断，如果回调函数返回 false （if (callback.call(elements[i], i, elements[i]) === false)） ，立即中断遍历。 $.each 调用结束后，会将遍历的数组或对象（ elements ）返回。 $.map可以遍历数组（类数组）或对象中的元素，根据回调函数的返回值，将返回值组成一个新的数组，并将该数组扁平化后返回，会将 null 及 undefined 排除。 123456789101112131415$.map = function(elements, callback) &#123; var value, values = [], i, key if (likeArray(elements)) for (i = 0; i &lt; elements.length; i++) &#123; value = callback(elements[i], i) if (value != null) values.push(value) &#125; else for (key in elements) &#123; value = callback(elements[key], key) if (value != null) values.push(value) &#125; return flatten(values) &#125; 先来看看调用方式： $.map(collection, function(item, index){ ... }) elements 为类数组或者对象。callback 为回调函数。当为类数组时，用 for 循环，当为对象时，用 for···in 循环。并且将对应的元素（属性值）及索引（属性名）传递给回调函数，如果回调函数的返回值不为 null 或者 undefined ，则将返回值存入新数组中，最后将新数组扁平化后返回。 $.camelCase该方法是将字符串转换成驼峰式的字符串 1$.camelCase = camelize $.camelCase 调用的是内部方法 camelize ,该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述，本篇文章就不再展开。 $.contains用来检查给定的父节点中是否包含有给定的子节点，源码如下： 123456789$.contains = document.documentElement.contains ? function(parent, node) &#123; return parent !== node &amp;&amp; parent.contains(node) &#125; : function(parent, node) &#123; while (node &amp;&amp; (node = node.parentNode)) if (node === parent) return true return false &#125; 先来看看调用：$.contains(parent, node) 参数 parent 为父子点，node 为子节点。 $.contains 的主体是一个三元表达式，返回的是一个匿名函数。三元表达式的条件是 document.documentElement.contains， 用来检测浏览器是否支持 contains 方法，如果支持，则直接调用 contains 方法，并且将 parent 和 node 为同一个元素的情况排除。 否则，返回另一外匿名函数。该函数会一直向上寻找 node 元素的父元素，如果能找到跟 parent 相等的父元素，则返回 true， 否则返回 false $.grep该函数其实就是数组的 filter 函数 123$.grep = function(elements, callback) &#123; return filter.call(elements, callback) &#125; 从源码中也可以看出，$.grep 调用的就是数组方法 filter $.inArray返回指定元素在数组中的索引值 123$.inArray = function(elem, array, i) &#123; return emptyArray.indexOf.call(array, elem, i) &#125; 先来看看调用 $.inArray(element, array, [fromIndex]) 第一个参数 element 为指定的元素，第二个参数为 array 为数组， 第三个参数 fromIndex 为可选参数，表示从哪个索引值开始向后查找。 $.inArray 其实调用的是数组的 indexOf 方法，所以传递的参数跟 indexOf 方法一致。 $.isArray判断是否为数组 1$.isArray = isArray $.isArray 调用的是内部方法 isArray ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isFunction判读是否为函数 1$.isFunction = isFunction $.isFunction 调用的是内部方法 isFunction ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isNumeric是否为数值 12345678910$.isNumeric = function(val) &#123; var num = Number(val), // 将参数转换为Number类型 type = typeof val return val != null &amp;&amp; type != 'boolean' &amp;&amp; (type != 'string' || val.length) &amp;&amp; !isNaN(num) &amp;&amp; isFinite(num) || false &#125; 判断是否为数值，需要满足以下条件 不为 null 不为布尔值 不为NaN(当传进来的参数不为数值或如&#39;123&#39;这样形式的字符串时，都会转换成NaN) 为有限数值 当传进来的参数为字符串的形式，如&#39;123&#39; 时，会用到下面这个条件来确保字符串为数字的形式，而不是如 123abc 这样的形式。(type != &#39;string&#39; || val.length) &amp;&amp; !isNaN(num) 。这个条件的包含逻辑如下：如果为字符串类型，并且为字符串的长度大于零，并且转换成数组后的结果不为NaN，则断定为数值。（因为 Number(&#39;&#39;) 的值为 0） $.isPlainObject是否为纯粹对象，即以 {} 常量或 new Object() 创建的对象 1$.isPlainObject = isPlainObject $.isPlainObject 调用的是内部方法isPlainObject ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isWindow是否为浏览器的 window 对象 1$.isWindow = isWindow $.isWindow 调用的是内部方法 isWindow ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.noop空函数 1$.noop = function() &#123;&#125; 这个在需要传递回调函数作为参数，但是又不想在回调函数中做任何事情的时候会非常有用，这时，只需要传递一个空函数即可。 $.parseJSON将标准JSON格式的字符串解释成JSON 1if (window.JSON) $.parseJSON = JSON.parse 其实就是调用原生的 JSON.parse， 并且在浏览器不支持的情况下，zepto 还不提供这个方法。 $.trim删除字符串头尾的空格 123$.trim = function(str) &#123; return str == null ? \"\" : String.prototype.trim.call(str)&#125; 如果参数为 null 或者 undefined ，则直接返回空字符串，否则调用字符串原生的 trim 方法去除头尾的空格。 $.type类型检测 1$.type = type $.type 调用的是内部方法 type ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 能检测的类型有 &quot;Boolean Number String Function Array Date RegExp Object Error&quot; 系列文章 读Zepto源码之代码结构 读 Zepto 源码之内部方法 参考 Zepto中文文档 Node.contains() Array.prototype.indexOf() String.prototype.trim() License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见： 作者：对角另一面","categories":[],"tags":[]},{"title":"读zepto源码之工具函数","slug":"读Zepto源码之工具函数的副本 4","date":"2018-04-09T12:50:33.000Z","updated":"2018-05-09T13:59:13.966Z","comments":true,"path":"2018/04/09/读Zepto源码之工具函数的副本 4/","link":"","permalink":"http://changguo.io/2018/04/09/读Zepto源码之工具函数的副本 4/","excerpt":"","text":"读zepto源码之工具函数Zepto 提供了丰富的工具函数，下面来一一解读。 源码版本本文阅读的源码为 zepto1.2.0 GitBook《reading-zepto》 $.extend$.extend 方法可以用来扩展目标对象的属性。目标对象的同名属性会被源对象的属性覆盖。 $.extend 其实调用的是内部方法 extend， 所以我们先看看内部方法 extend 的具体实现。 12345678910function extend(target, source, deep) &#123; for (key in source) // 遍历源对象的属性值 if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123; // 如果为深度复制，并且源对象的属性值为纯粹对象或者数组 if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) // 如果为纯粹对象 target[key] = &#123;&#125; // 如果源对象的属性值为纯粹对象，并且目标对象对应的属性值不为纯粹对象，则将目标对象对应的属性值置为空对象 if (isArray(source[key]) &amp;&amp; !isArray(target[key])) // 如果源对象的属性值为数组，并且目标对象对应的属性值不为数组，则将目标对象对应的属性值置为空数组 target[key] = [] extend(target[key], source[key], deep) // 递归调用extend函数 &#125; else if (source[key] !== undefined) target[key] = source[key] // 不对undefined值进行复制 &#125; extend 的第一个参数 taget 为目标对象， source 为源对象， deep 表示是否为深度复制。当 deep 为 true 时为深度复制， false 时为浅复制。 extend 函数用 for···in 对 source 的属性进行遍历 如果 deep 为 false 时，只进行浅复制，将 source 中不为 undefined 的值赋值到 target 对应的属性中（注意，这里用的是 !==，不是 != ，所以只排除严格为 undefined 的值，不包含 null ）。如果 source 对应的属性值为对象或者数组，会保持该对象或数组的引用。 如果 deep 为 true ，并且 source 的属性值为纯粹对象或者数组时 3.1. 如果 source 的属性为纯粹对象，并且 target 对应的属性不为纯粹对象时，将 target 的对应属性设置为空对象 3.2. 如果 source 的属性为数组，并且 target 对应属性不为数组时，将 target 的对应属性设置为空数组 3.3. 将 source 和 target 对应的属性及 deep 作为参数，递归调用 extend 函数，以实现深度复制。 现在，再看看 $.extend 的具体实现 123456789$.extend = function(target) &#123; var deep, args = slice.call(arguments, 1) if (typeof target == 'boolean') &#123; deep = target target = args.shift() &#125; args.forEach(function(arg) &#123; extend(target, arg, deep) &#125;) return target &#125; 在说原理之前，先来看看 $.extend 的调用方式，调用方式如下： 123$.extend(target, [source, [source2, ...]]) 或$.extend(true, target, [source, ...]) 在 $.extend 中，如果不需要深度复制，第一个参数可以是目标对象 target, 后面可以有多个 source 源对象。如果需要深度复制，第一个参数为 deep ，第二个参数为 target ，为目标对象，后面可以有多个 source 源对象。 $.extend 函数的参数设计得很优雅，不需要深度复制时，可以不用显式地将 deep 置为 false。这是如何做到的呢？ 在 $.extend 函数中，定义了一个数组 args，用来接受除第一个参数外的所有参数。 然后判断第一个参数 target 是否为布尔值，如果为布尔值，表示第一个参数为 deep ，那么第二个才为目标对象，因此需要重新为 target 赋值为 args.shift() 。 最后就比较简单了，循环源对象数组 args， 分别调用 extend 方法，实现对目标对象的扩展。 $.each$.each 用来遍历数组或者对象，源码如下： 123456789101112$.each = function(elements, callback) &#123; var i, key if (likeArray(elements)) &#123; // 类数组 for (i = 0; i &lt; elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements &#125; else &#123; // 对象 for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements &#125; return elements &#125; 先来看看调用方式：$.each(collection, function(index, item){ ... }) $.each 接收两个参数，第一个参数 elements 为需要遍历的数组或者对象，第二个 callback 为回调函数。 如果 elements 为数组，用 for 循环，调用 callback ，并且将数组索引 index 和元素值 item 传给回调函数作为参数；如果为对象，用 for···in 遍历属性值，并且将属性 key 及属性值传给回调函数作为参数。 注意回调函数调用了 call 方法，call 的第一个参数为当前元素值或当前属性值，所以回调函数的上下文变成了当前元素值或属性值，也就是说回调函数中的 this 指向的是 item 。这在dom集合的遍历中相当有用。 在遍历的时候，还对回调函数的返回值进行判断，如果回调函数返回 false （if (callback.call(elements[i], i, elements[i]) === false)） ，立即中断遍历。 $.each 调用结束后，会将遍历的数组或对象（ elements ）返回。 $.map可以遍历数组（类数组）或对象中的元素，根据回调函数的返回值，将返回值组成一个新的数组，并将该数组扁平化后返回，会将 null 及 undefined 排除。 123456789101112131415$.map = function(elements, callback) &#123; var value, values = [], i, key if (likeArray(elements)) for (i = 0; i &lt; elements.length; i++) &#123; value = callback(elements[i], i) if (value != null) values.push(value) &#125; else for (key in elements) &#123; value = callback(elements[key], key) if (value != null) values.push(value) &#125; return flatten(values) &#125; 先来看看调用方式： $.map(collection, function(item, index){ ... }) elements 为类数组或者对象。callback 为回调函数。当为类数组时，用 for 循环，当为对象时，用 for···in 循环。并且将对应的元素（属性值）及索引（属性名）传递给回调函数，如果回调函数的返回值不为 null 或者 undefined ，则将返回值存入新数组中，最后将新数组扁平化后返回。 $.camelCase该方法是将字符串转换成驼峰式的字符串 1$.camelCase = camelize $.camelCase 调用的是内部方法 camelize ,该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述，本篇文章就不再展开。 $.contains用来检查给定的父节点中是否包含有给定的子节点，源码如下： 123456789$.contains = document.documentElement.contains ? function(parent, node) &#123; return parent !== node &amp;&amp; parent.contains(node) &#125; : function(parent, node) &#123; while (node &amp;&amp; (node = node.parentNode)) if (node === parent) return true return false &#125; 先来看看调用：$.contains(parent, node) 参数 parent 为父子点，node 为子节点。 $.contains 的主体是一个三元表达式，返回的是一个匿名函数。三元表达式的条件是 document.documentElement.contains， 用来检测浏览器是否支持 contains 方法，如果支持，则直接调用 contains 方法，并且将 parent 和 node 为同一个元素的情况排除。 否则，返回另一外匿名函数。该函数会一直向上寻找 node 元素的父元素，如果能找到跟 parent 相等的父元素，则返回 true， 否则返回 false $.grep该函数其实就是数组的 filter 函数 123$.grep = function(elements, callback) &#123; return filter.call(elements, callback) &#125; 从源码中也可以看出，$.grep 调用的就是数组方法 filter $.inArray返回指定元素在数组中的索引值 123$.inArray = function(elem, array, i) &#123; return emptyArray.indexOf.call(array, elem, i) &#125; 先来看看调用 $.inArray(element, array, [fromIndex]) 第一个参数 element 为指定的元素，第二个参数为 array 为数组， 第三个参数 fromIndex 为可选参数，表示从哪个索引值开始向后查找。 $.inArray 其实调用的是数组的 indexOf 方法，所以传递的参数跟 indexOf 方法一致。 $.isArray判断是否为数组 1$.isArray = isArray $.isArray 调用的是内部方法 isArray ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isFunction判读是否为函数 1$.isFunction = isFunction $.isFunction 调用的是内部方法 isFunction ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isNumeric是否为数值 12345678910$.isNumeric = function(val) &#123; var num = Number(val), // 将参数转换为Number类型 type = typeof val return val != null &amp;&amp; type != 'boolean' &amp;&amp; (type != 'string' || val.length) &amp;&amp; !isNaN(num) &amp;&amp; isFinite(num) || false &#125; 判断是否为数值，需要满足以下条件 不为 null 不为布尔值 不为NaN(当传进来的参数不为数值或如&#39;123&#39;这样形式的字符串时，都会转换成NaN) 为有限数值 当传进来的参数为字符串的形式，如&#39;123&#39; 时，会用到下面这个条件来确保字符串为数字的形式，而不是如 123abc 这样的形式。(type != &#39;string&#39; || val.length) &amp;&amp; !isNaN(num) 。这个条件的包含逻辑如下：如果为字符串类型，并且为字符串的长度大于零，并且转换成数组后的结果不为NaN，则断定为数值。（因为 Number(&#39;&#39;) 的值为 0） $.isPlainObject是否为纯粹对象，即以 {} 常量或 new Object() 创建的对象 1$.isPlainObject = isPlainObject $.isPlainObject 调用的是内部方法isPlainObject ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isWindow是否为浏览器的 window 对象 1$.isWindow = isWindow $.isWindow 调用的是内部方法 isWindow ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.noop空函数 1$.noop = function() &#123;&#125; 这个在需要传递回调函数作为参数，但是又不想在回调函数中做任何事情的时候会非常有用，这时，只需要传递一个空函数即可。 $.parseJSON将标准JSON格式的字符串解释成JSON 1if (window.JSON) $.parseJSON = JSON.parse 其实就是调用原生的 JSON.parse， 并且在浏览器不支持的情况下，zepto 还不提供这个方法。 $.trim删除字符串头尾的空格 123$.trim = function(str) &#123; return str == null ? \"\" : String.prototype.trim.call(str)&#125; 如果参数为 null 或者 undefined ，则直接返回空字符串，否则调用字符串原生的 trim 方法去除头尾的空格。 $.type类型检测 1$.type = type $.type 调用的是内部方法 type ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 能检测的类型有 &quot;Boolean Number String Function Array Date RegExp Object Error&quot; 系列文章 读Zepto源码之代码结构 读 Zepto 源码之内部方法 参考 Zepto中文文档 Node.contains() Array.prototype.indexOf() String.prototype.trim() License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见： 作者：对角另一面","categories":[],"tags":[]},{"title":"读Zepto源码之集合操作","slug":"读Zepto源码之集合操作的副本","date":"2018-04-09T12:50:33.000Z","updated":"2018-05-09T13:59:53.445Z","comments":true,"path":"2018/04/09/读Zepto源码之集合操作的副本/","link":"","permalink":"http://changguo.io/2018/04/09/读Zepto源码之集合操作的副本/","excerpt":"","text":"读Zepto源码之集合操作接下来几个篇章，都会解读 zepto 中的跟 dom 相关的方法，也即源码 $.fn 对象中的方法。 读Zepto源码系列文章已经放到了github上，欢迎star: reading-zepto 源码版本本文阅读的源码为 zepto1.2.0 GitBook《reading-zepto》 .forEach()1forEach: emptyArray.forEach 因为 zepto 的 dom 集合是类数组，所以这里只是简单地复制了数组的 forEach 方法。 具体的 forEach 的用法见文档:Array.prototype.forEach() .reduce()1reduce: emptyArray.reduce 简单地复制了数组的 reduce 方法。 具体的 reduce 的用法见文档:Array.prototype.reduce() .push()1push: emptyArray.push 简单地复制了数组的 push 方法。 具体的 push 的用法见文档:Array.prototype.push() .sort()1sort: emptyArray.sort 简单地复制了数组的 sort 方法。 具体的 sort 的用法见文档:Array.prototype.sort() .splice()1splice: emptyArray.splice 简单地复制了数组的 splice 方法。 具体的 splice 的用法见文档:Array.prototype.splice() .indexOf()1indexOf: emptyArray.indexOf 简单地复制了数组的 indexOf 方法。 具体的 indexOf 的用法见文档:Array.prototype.indexOf() .get()123get: function(idx) &#123; return idx === undefined ? slice.call(this) : this[idx &gt;= 0 ? idx : idx + this.length]&#125;, 这个方法用来获取指定索引值的元素。 不传参（idx === undefined）时，不传参调用数组的 slice 方法，将集合中的所有元素返回。 当传递的参数大于或等于零（idx）时，返回相应索引值的元素 this[idx] ，如果为负数，则倒数返回this.[idx + this.length]。 例如 $(&#39;li&#39;).get(-1) 返回的是倒数第1个元素，也即最后一个元素 .toArray()1toArray: function() &#123; return this.get() &#125; toArray 方法是将元素的类数组变成纯数组。toArray 内部不传参调用 get 方法，上面已经分析了，当不传参数时，get 方法调用的是数组方法 slice， 返回的自然就是纯数组了。 .size()123size: function() &#123; return this.length&#125; size 方法返回的是集合中的 length 属性，也即集合中元素的个数。 .concat()12345678concat: function() &#123; var i, value, args = [] for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value &#125; return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)&#125;, 数组中也有对应的 concat 方法，为什么不能像上面的方法那样直接调用呢？ 这是因为 $.fn 其实是一个类数组对象，并不是真正的数组，如果直接调用 concat 会直接把整个 $.fn 当成数组的一个 item 合并到数组中。 1234for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value&#125; 这段是对每个参数进行判断，如果参数是 zepto 的集合（zepto.isZ(value)），就先调用 toArray 方法，转换成纯数组。 1return concat.apply(zepto.isZ(this) ? this.toArray() : this, args) 这段同样对 this 进行了判断，如果为 zepto 集合，也先转换成数组。所以调用 concat 后返回的是纯数组，不再是 zepto 集合。 .map()123map: function(fn) &#123; return $($.map(this, function(el, i) &#123; return fn.call(el, i, el) &#125;))&#125; map 方法的内部调用的是 zepto 的工具函数 $.map ，这在之前已经在《读Zepto源码之工具函数》做过了分析。 1return fn.call(el, i, el) map 方法对回调也做了包装，call 的第一个参数为 el ，因此可以在 map 的回调中通过 this 来拿到每个元素。 map 方法对 $.map 返回的数组调用了 $() 方法，将返回的数组再次包装成 zepto 对象，因此调用 map 方法后得到的数组，同样具有 zepto 集合中的方法。 .slice()123slice: function() &#123; return $(slice.apply(this, arguments))&#125; slice 同样没有直接用数组的原生方法，也像 map 方法一样，将返回的数组再次包装成 zepto 对象。 .each()123456each: function(callback) &#123; emptyArray.every.call(this, function(el, idx) &#123; return callback.call(el, idx, el) !== false &#125;) return this&#125;, zepto 的 each 方法比较巧妙，在方法内部，调用的其实是数组的 every 方法，every 遇到 false 时就会中止遍历，zepto 也正是利用 every 这种特性，让 each 方法也具有了中止遍历的能力，当 callback 返回的值为布尔值 false 时，中止遍历，注意这里用了 !==，因为 callback 如果没有返回值时，得到的值会是 undefined ，这种情况是需要排除的。 同样，each 的回调中也是可以用 this 拿到每个元素的。 注意，each 方法最后返回的是 this， 所以在 each 调用完后，还可以继续调用 集合中的其他方法，这就是 zepto 的链式调用，这个跟 map 方法中返回 zepto 集合的原理差不多，只不过 each 返回的是跟原来一样的集合，map 方法返回的是映射后的集合。 .add()123add: function(selector, context) &#123; return $(uniq(this.concat($(selector, context))))&#125; add 可以传递两个参数，selector 和 context ，即选择器和上下文。 add 调用 $(selector, context) 来获取符合条件的集合元素，这在上篇文章《读Zepto源码之神奇的$》已经有详细的论述。 然后调用 concat 方法来合并两个集合，用内部方法 uniq 来过滤掉重复的项，uniq 方法在《读Zepto源码之内部方法》已经有论述。最后也是返回一个 zepto 集合。 系列文章 读Zepto源码之代码结构 读 Zepto 源码之内部方法 读Zepto源码之工具函数 读Zepto源码之神奇的$ 参考 Array.prototype.forEach() Array.prototype.reduce() Array.prototype.push() Array.prototype.sort() Array.prototype.splice() Array.prototype.indexOf() License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见： 作者：对角另一面","categories":[],"tags":[]},{"title":"读zepto源码之工具函数","slug":"读Zepto源码之工具函数的副本 6","date":"2018-04-09T12:50:33.000Z","updated":"2018-05-09T13:59:13.966Z","comments":true,"path":"2018/04/09/读Zepto源码之工具函数的副本 6/","link":"","permalink":"http://changguo.io/2018/04/09/读Zepto源码之工具函数的副本 6/","excerpt":"","text":"读zepto源码之工具函数Zepto 提供了丰富的工具函数，下面来一一解读。 源码版本本文阅读的源码为 zepto1.2.0 GitBook《reading-zepto》 $.extend$.extend 方法可以用来扩展目标对象的属性。目标对象的同名属性会被源对象的属性覆盖。 $.extend 其实调用的是内部方法 extend， 所以我们先看看内部方法 extend 的具体实现。 12345678910function extend(target, source, deep) &#123; for (key in source) // 遍历源对象的属性值 if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123; // 如果为深度复制，并且源对象的属性值为纯粹对象或者数组 if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) // 如果为纯粹对象 target[key] = &#123;&#125; // 如果源对象的属性值为纯粹对象，并且目标对象对应的属性值不为纯粹对象，则将目标对象对应的属性值置为空对象 if (isArray(source[key]) &amp;&amp; !isArray(target[key])) // 如果源对象的属性值为数组，并且目标对象对应的属性值不为数组，则将目标对象对应的属性值置为空数组 target[key] = [] extend(target[key], source[key], deep) // 递归调用extend函数 &#125; else if (source[key] !== undefined) target[key] = source[key] // 不对undefined值进行复制 &#125; extend 的第一个参数 taget 为目标对象， source 为源对象， deep 表示是否为深度复制。当 deep 为 true 时为深度复制， false 时为浅复制。 extend 函数用 for···in 对 source 的属性进行遍历 如果 deep 为 false 时，只进行浅复制，将 source 中不为 undefined 的值赋值到 target 对应的属性中（注意，这里用的是 !==，不是 != ，所以只排除严格为 undefined 的值，不包含 null ）。如果 source 对应的属性值为对象或者数组，会保持该对象或数组的引用。 如果 deep 为 true ，并且 source 的属性值为纯粹对象或者数组时 3.1. 如果 source 的属性为纯粹对象，并且 target 对应的属性不为纯粹对象时，将 target 的对应属性设置为空对象 3.2. 如果 source 的属性为数组，并且 target 对应属性不为数组时，将 target 的对应属性设置为空数组 3.3. 将 source 和 target 对应的属性及 deep 作为参数，递归调用 extend 函数，以实现深度复制。 现在，再看看 $.extend 的具体实现 123456789$.extend = function(target) &#123; var deep, args = slice.call(arguments, 1) if (typeof target == 'boolean') &#123; deep = target target = args.shift() &#125; args.forEach(function(arg) &#123; extend(target, arg, deep) &#125;) return target &#125; 在说原理之前，先来看看 $.extend 的调用方式，调用方式如下： 123$.extend(target, [source, [source2, ...]]) 或$.extend(true, target, [source, ...]) 在 $.extend 中，如果不需要深度复制，第一个参数可以是目标对象 target, 后面可以有多个 source 源对象。如果需要深度复制，第一个参数为 deep ，第二个参数为 target ，为目标对象，后面可以有多个 source 源对象。 $.extend 函数的参数设计得很优雅，不需要深度复制时，可以不用显式地将 deep 置为 false。这是如何做到的呢？ 在 $.extend 函数中，定义了一个数组 args，用来接受除第一个参数外的所有参数。 然后判断第一个参数 target 是否为布尔值，如果为布尔值，表示第一个参数为 deep ，那么第二个才为目标对象，因此需要重新为 target 赋值为 args.shift() 。 最后就比较简单了，循环源对象数组 args， 分别调用 extend 方法，实现对目标对象的扩展。 $.each$.each 用来遍历数组或者对象，源码如下： 123456789101112$.each = function(elements, callback) &#123; var i, key if (likeArray(elements)) &#123; // 类数组 for (i = 0; i &lt; elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements &#125; else &#123; // 对象 for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements &#125; return elements &#125; 先来看看调用方式：$.each(collection, function(index, item){ ... }) $.each 接收两个参数，第一个参数 elements 为需要遍历的数组或者对象，第二个 callback 为回调函数。 如果 elements 为数组，用 for 循环，调用 callback ，并且将数组索引 index 和元素值 item 传给回调函数作为参数；如果为对象，用 for···in 遍历属性值，并且将属性 key 及属性值传给回调函数作为参数。 注意回调函数调用了 call 方法，call 的第一个参数为当前元素值或当前属性值，所以回调函数的上下文变成了当前元素值或属性值，也就是说回调函数中的 this 指向的是 item 。这在dom集合的遍历中相当有用。 在遍历的时候，还对回调函数的返回值进行判断，如果回调函数返回 false （if (callback.call(elements[i], i, elements[i]) === false)） ，立即中断遍历。 $.each 调用结束后，会将遍历的数组或对象（ elements ）返回。 $.map可以遍历数组（类数组）或对象中的元素，根据回调函数的返回值，将返回值组成一个新的数组，并将该数组扁平化后返回，会将 null 及 undefined 排除。 123456789101112131415$.map = function(elements, callback) &#123; var value, values = [], i, key if (likeArray(elements)) for (i = 0; i &lt; elements.length; i++) &#123; value = callback(elements[i], i) if (value != null) values.push(value) &#125; else for (key in elements) &#123; value = callback(elements[key], key) if (value != null) values.push(value) &#125; return flatten(values) &#125; 先来看看调用方式： $.map(collection, function(item, index){ ... }) elements 为类数组或者对象。callback 为回调函数。当为类数组时，用 for 循环，当为对象时，用 for···in 循环。并且将对应的元素（属性值）及索引（属性名）传递给回调函数，如果回调函数的返回值不为 null 或者 undefined ，则将返回值存入新数组中，最后将新数组扁平化后返回。 $.camelCase该方法是将字符串转换成驼峰式的字符串 1$.camelCase = camelize $.camelCase 调用的是内部方法 camelize ,该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述，本篇文章就不再展开。 $.contains用来检查给定的父节点中是否包含有给定的子节点，源码如下： 123456789$.contains = document.documentElement.contains ? function(parent, node) &#123; return parent !== node &amp;&amp; parent.contains(node) &#125; : function(parent, node) &#123; while (node &amp;&amp; (node = node.parentNode)) if (node === parent) return true return false &#125; 先来看看调用：$.contains(parent, node) 参数 parent 为父子点，node 为子节点。 $.contains 的主体是一个三元表达式，返回的是一个匿名函数。三元表达式的条件是 document.documentElement.contains， 用来检测浏览器是否支持 contains 方法，如果支持，则直接调用 contains 方法，并且将 parent 和 node 为同一个元素的情况排除。 否则，返回另一外匿名函数。该函数会一直向上寻找 node 元素的父元素，如果能找到跟 parent 相等的父元素，则返回 true， 否则返回 false $.grep该函数其实就是数组的 filter 函数 123$.grep = function(elements, callback) &#123; return filter.call(elements, callback) &#125; 从源码中也可以看出，$.grep 调用的就是数组方法 filter $.inArray返回指定元素在数组中的索引值 123$.inArray = function(elem, array, i) &#123; return emptyArray.indexOf.call(array, elem, i) &#125; 先来看看调用 $.inArray(element, array, [fromIndex]) 第一个参数 element 为指定的元素，第二个参数为 array 为数组， 第三个参数 fromIndex 为可选参数，表示从哪个索引值开始向后查找。 $.inArray 其实调用的是数组的 indexOf 方法，所以传递的参数跟 indexOf 方法一致。 $.isArray判断是否为数组 1$.isArray = isArray $.isArray 调用的是内部方法 isArray ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isFunction判读是否为函数 1$.isFunction = isFunction $.isFunction 调用的是内部方法 isFunction ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isNumeric是否为数值 12345678910$.isNumeric = function(val) &#123; var num = Number(val), // 将参数转换为Number类型 type = typeof val return val != null &amp;&amp; type != 'boolean' &amp;&amp; (type != 'string' || val.length) &amp;&amp; !isNaN(num) &amp;&amp; isFinite(num) || false &#125; 判断是否为数值，需要满足以下条件 不为 null 不为布尔值 不为NaN(当传进来的参数不为数值或如&#39;123&#39;这样形式的字符串时，都会转换成NaN) 为有限数值 当传进来的参数为字符串的形式，如&#39;123&#39; 时，会用到下面这个条件来确保字符串为数字的形式，而不是如 123abc 这样的形式。(type != &#39;string&#39; || val.length) &amp;&amp; !isNaN(num) 。这个条件的包含逻辑如下：如果为字符串类型，并且为字符串的长度大于零，并且转换成数组后的结果不为NaN，则断定为数值。（因为 Number(&#39;&#39;) 的值为 0） $.isPlainObject是否为纯粹对象，即以 {} 常量或 new Object() 创建的对象 1$.isPlainObject = isPlainObject $.isPlainObject 调用的是内部方法isPlainObject ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isWindow是否为浏览器的 window 对象 1$.isWindow = isWindow $.isWindow 调用的是内部方法 isWindow ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.noop空函数 1$.noop = function() &#123;&#125; 这个在需要传递回调函数作为参数，但是又不想在回调函数中做任何事情的时候会非常有用，这时，只需要传递一个空函数即可。 $.parseJSON将标准JSON格式的字符串解释成JSON 1if (window.JSON) $.parseJSON = JSON.parse 其实就是调用原生的 JSON.parse， 并且在浏览器不支持的情况下，zepto 还不提供这个方法。 $.trim删除字符串头尾的空格 123$.trim = function(str) &#123; return str == null ? \"\" : String.prototype.trim.call(str)&#125; 如果参数为 null 或者 undefined ，则直接返回空字符串，否则调用字符串原生的 trim 方法去除头尾的空格。 $.type类型检测 1$.type = type $.type 调用的是内部方法 type ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 能检测的类型有 &quot;Boolean Number String Function Array Date RegExp Object Error&quot; 系列文章 读Zepto源码之代码结构 读 Zepto 源码之内部方法 参考 Zepto中文文档 Node.contains() Array.prototype.indexOf() String.prototype.trim() License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见： 作者：对角另一面","categories":[],"tags":[]},{"title":"读zepto源码之工具函数","slug":"读Zepto源码之工具函数的副本 7","date":"2018-04-09T12:50:33.000Z","updated":"2018-05-09T13:59:13.966Z","comments":true,"path":"2018/04/09/读Zepto源码之工具函数的副本 7/","link":"","permalink":"http://changguo.io/2018/04/09/读Zepto源码之工具函数的副本 7/","excerpt":"","text":"读zepto源码之工具函数Zepto 提供了丰富的工具函数，下面来一一解读。 源码版本本文阅读的源码为 zepto1.2.0 GitBook《reading-zepto》 $.extend$.extend 方法可以用来扩展目标对象的属性。目标对象的同名属性会被源对象的属性覆盖。 $.extend 其实调用的是内部方法 extend， 所以我们先看看内部方法 extend 的具体实现。 12345678910function extend(target, source, deep) &#123; for (key in source) // 遍历源对象的属性值 if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123; // 如果为深度复制，并且源对象的属性值为纯粹对象或者数组 if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) // 如果为纯粹对象 target[key] = &#123;&#125; // 如果源对象的属性值为纯粹对象，并且目标对象对应的属性值不为纯粹对象，则将目标对象对应的属性值置为空对象 if (isArray(source[key]) &amp;&amp; !isArray(target[key])) // 如果源对象的属性值为数组，并且目标对象对应的属性值不为数组，则将目标对象对应的属性值置为空数组 target[key] = [] extend(target[key], source[key], deep) // 递归调用extend函数 &#125; else if (source[key] !== undefined) target[key] = source[key] // 不对undefined值进行复制 &#125; extend 的第一个参数 taget 为目标对象， source 为源对象， deep 表示是否为深度复制。当 deep 为 true 时为深度复制， false 时为浅复制。 extend 函数用 for···in 对 source 的属性进行遍历 如果 deep 为 false 时，只进行浅复制，将 source 中不为 undefined 的值赋值到 target 对应的属性中（注意，这里用的是 !==，不是 != ，所以只排除严格为 undefined 的值，不包含 null ）。如果 source 对应的属性值为对象或者数组，会保持该对象或数组的引用。 如果 deep 为 true ，并且 source 的属性值为纯粹对象或者数组时 3.1. 如果 source 的属性为纯粹对象，并且 target 对应的属性不为纯粹对象时，将 target 的对应属性设置为空对象 3.2. 如果 source 的属性为数组，并且 target 对应属性不为数组时，将 target 的对应属性设置为空数组 3.3. 将 source 和 target 对应的属性及 deep 作为参数，递归调用 extend 函数，以实现深度复制。 现在，再看看 $.extend 的具体实现 123456789$.extend = function(target) &#123; var deep, args = slice.call(arguments, 1) if (typeof target == 'boolean') &#123; deep = target target = args.shift() &#125; args.forEach(function(arg) &#123; extend(target, arg, deep) &#125;) return target &#125; 在说原理之前，先来看看 $.extend 的调用方式，调用方式如下： 123$.extend(target, [source, [source2, ...]]) 或$.extend(true, target, [source, ...]) 在 $.extend 中，如果不需要深度复制，第一个参数可以是目标对象 target, 后面可以有多个 source 源对象。如果需要深度复制，第一个参数为 deep ，第二个参数为 target ，为目标对象，后面可以有多个 source 源对象。 $.extend 函数的参数设计得很优雅，不需要深度复制时，可以不用显式地将 deep 置为 false。这是如何做到的呢？ 在 $.extend 函数中，定义了一个数组 args，用来接受除第一个参数外的所有参数。 然后判断第一个参数 target 是否为布尔值，如果为布尔值，表示第一个参数为 deep ，那么第二个才为目标对象，因此需要重新为 target 赋值为 args.shift() 。 最后就比较简单了，循环源对象数组 args， 分别调用 extend 方法，实现对目标对象的扩展。 $.each$.each 用来遍历数组或者对象，源码如下： 123456789101112$.each = function(elements, callback) &#123; var i, key if (likeArray(elements)) &#123; // 类数组 for (i = 0; i &lt; elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements &#125; else &#123; // 对象 for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements &#125; return elements &#125; 先来看看调用方式：$.each(collection, function(index, item){ ... }) $.each 接收两个参数，第一个参数 elements 为需要遍历的数组或者对象，第二个 callback 为回调函数。 如果 elements 为数组，用 for 循环，调用 callback ，并且将数组索引 index 和元素值 item 传给回调函数作为参数；如果为对象，用 for···in 遍历属性值，并且将属性 key 及属性值传给回调函数作为参数。 注意回调函数调用了 call 方法，call 的第一个参数为当前元素值或当前属性值，所以回调函数的上下文变成了当前元素值或属性值，也就是说回调函数中的 this 指向的是 item 。这在dom集合的遍历中相当有用。 在遍历的时候，还对回调函数的返回值进行判断，如果回调函数返回 false （if (callback.call(elements[i], i, elements[i]) === false)） ，立即中断遍历。 $.each 调用结束后，会将遍历的数组或对象（ elements ）返回。 $.map可以遍历数组（类数组）或对象中的元素，根据回调函数的返回值，将返回值组成一个新的数组，并将该数组扁平化后返回，会将 null 及 undefined 排除。 123456789101112131415$.map = function(elements, callback) &#123; var value, values = [], i, key if (likeArray(elements)) for (i = 0; i &lt; elements.length; i++) &#123; value = callback(elements[i], i) if (value != null) values.push(value) &#125; else for (key in elements) &#123; value = callback(elements[key], key) if (value != null) values.push(value) &#125; return flatten(values) &#125; 先来看看调用方式： $.map(collection, function(item, index){ ... }) elements 为类数组或者对象。callback 为回调函数。当为类数组时，用 for 循环，当为对象时，用 for···in 循环。并且将对应的元素（属性值）及索引（属性名）传递给回调函数，如果回调函数的返回值不为 null 或者 undefined ，则将返回值存入新数组中，最后将新数组扁平化后返回。 $.camelCase该方法是将字符串转换成驼峰式的字符串 1$.camelCase = camelize $.camelCase 调用的是内部方法 camelize ,该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述，本篇文章就不再展开。 $.contains用来检查给定的父节点中是否包含有给定的子节点，源码如下： 123456789$.contains = document.documentElement.contains ? function(parent, node) &#123; return parent !== node &amp;&amp; parent.contains(node) &#125; : function(parent, node) &#123; while (node &amp;&amp; (node = node.parentNode)) if (node === parent) return true return false &#125; 先来看看调用：$.contains(parent, node) 参数 parent 为父子点，node 为子节点。 $.contains 的主体是一个三元表达式，返回的是一个匿名函数。三元表达式的条件是 document.documentElement.contains， 用来检测浏览器是否支持 contains 方法，如果支持，则直接调用 contains 方法，并且将 parent 和 node 为同一个元素的情况排除。 否则，返回另一外匿名函数。该函数会一直向上寻找 node 元素的父元素，如果能找到跟 parent 相等的父元素，则返回 true， 否则返回 false $.grep该函数其实就是数组的 filter 函数 123$.grep = function(elements, callback) &#123; return filter.call(elements, callback) &#125; 从源码中也可以看出，$.grep 调用的就是数组方法 filter $.inArray返回指定元素在数组中的索引值 123$.inArray = function(elem, array, i) &#123; return emptyArray.indexOf.call(array, elem, i) &#125; 先来看看调用 $.inArray(element, array, [fromIndex]) 第一个参数 element 为指定的元素，第二个参数为 array 为数组， 第三个参数 fromIndex 为可选参数，表示从哪个索引值开始向后查找。 $.inArray 其实调用的是数组的 indexOf 方法，所以传递的参数跟 indexOf 方法一致。 $.isArray判断是否为数组 1$.isArray = isArray $.isArray 调用的是内部方法 isArray ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isFunction判读是否为函数 1$.isFunction = isFunction $.isFunction 调用的是内部方法 isFunction ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isNumeric是否为数值 12345678910$.isNumeric = function(val) &#123; var num = Number(val), // 将参数转换为Number类型 type = typeof val return val != null &amp;&amp; type != 'boolean' &amp;&amp; (type != 'string' || val.length) &amp;&amp; !isNaN(num) &amp;&amp; isFinite(num) || false &#125; 判断是否为数值，需要满足以下条件 不为 null 不为布尔值 不为NaN(当传进来的参数不为数值或如&#39;123&#39;这样形式的字符串时，都会转换成NaN) 为有限数值 当传进来的参数为字符串的形式，如&#39;123&#39; 时，会用到下面这个条件来确保字符串为数字的形式，而不是如 123abc 这样的形式。(type != &#39;string&#39; || val.length) &amp;&amp; !isNaN(num) 。这个条件的包含逻辑如下：如果为字符串类型，并且为字符串的长度大于零，并且转换成数组后的结果不为NaN，则断定为数值。（因为 Number(&#39;&#39;) 的值为 0） $.isPlainObject是否为纯粹对象，即以 {} 常量或 new Object() 创建的对象 1$.isPlainObject = isPlainObject $.isPlainObject 调用的是内部方法isPlainObject ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isWindow是否为浏览器的 window 对象 1$.isWindow = isWindow $.isWindow 调用的是内部方法 isWindow ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.noop空函数 1$.noop = function() &#123;&#125; 这个在需要传递回调函数作为参数，但是又不想在回调函数中做任何事情的时候会非常有用，这时，只需要传递一个空函数即可。 $.parseJSON将标准JSON格式的字符串解释成JSON 1if (window.JSON) $.parseJSON = JSON.parse 其实就是调用原生的 JSON.parse， 并且在浏览器不支持的情况下，zepto 还不提供这个方法。 $.trim删除字符串头尾的空格 123$.trim = function(str) &#123; return str == null ? \"\" : String.prototype.trim.call(str)&#125; 如果参数为 null 或者 undefined ，则直接返回空字符串，否则调用字符串原生的 trim 方法去除头尾的空格。 $.type类型检测 1$.type = type $.type 调用的是内部方法 type ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 能检测的类型有 &quot;Boolean Number String Function Array Date RegExp Object Error&quot; 系列文章 读Zepto源码之代码结构 读 Zepto 源码之内部方法 参考 Zepto中文文档 Node.contains() Array.prototype.indexOf() String.prototype.trim() License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见： 作者：对角另一面","categories":[],"tags":[]},{"title":"读zepto源码之工具函数","slug":"读Zepto源码之工具函数的副本","date":"2018-04-09T12:50:33.000Z","updated":"2018-05-09T13:59:13.966Z","comments":true,"path":"2018/04/09/读Zepto源码之工具函数的副本/","link":"","permalink":"http://changguo.io/2018/04/09/读Zepto源码之工具函数的副本/","excerpt":"","text":"读zepto源码之工具函数Zepto 提供了丰富的工具函数，下面来一一解读。 源码版本本文阅读的源码为 zepto1.2.0 GitBook《reading-zepto》 $.extend$.extend 方法可以用来扩展目标对象的属性。目标对象的同名属性会被源对象的属性覆盖。 $.extend 其实调用的是内部方法 extend， 所以我们先看看内部方法 extend 的具体实现。 12345678910function extend(target, source, deep) &#123; for (key in source) // 遍历源对象的属性值 if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123; // 如果为深度复制，并且源对象的属性值为纯粹对象或者数组 if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) // 如果为纯粹对象 target[key] = &#123;&#125; // 如果源对象的属性值为纯粹对象，并且目标对象对应的属性值不为纯粹对象，则将目标对象对应的属性值置为空对象 if (isArray(source[key]) &amp;&amp; !isArray(target[key])) // 如果源对象的属性值为数组，并且目标对象对应的属性值不为数组，则将目标对象对应的属性值置为空数组 target[key] = [] extend(target[key], source[key], deep) // 递归调用extend函数 &#125; else if (source[key] !== undefined) target[key] = source[key] // 不对undefined值进行复制 &#125; extend 的第一个参数 taget 为目标对象， source 为源对象， deep 表示是否为深度复制。当 deep 为 true 时为深度复制， false 时为浅复制。 extend 函数用 for···in 对 source 的属性进行遍历 如果 deep 为 false 时，只进行浅复制，将 source 中不为 undefined 的值赋值到 target 对应的属性中（注意，这里用的是 !==，不是 != ，所以只排除严格为 undefined 的值，不包含 null ）。如果 source 对应的属性值为对象或者数组，会保持该对象或数组的引用。 如果 deep 为 true ，并且 source 的属性值为纯粹对象或者数组时 3.1. 如果 source 的属性为纯粹对象，并且 target 对应的属性不为纯粹对象时，将 target 的对应属性设置为空对象 3.2. 如果 source 的属性为数组，并且 target 对应属性不为数组时，将 target 的对应属性设置为空数组 3.3. 将 source 和 target 对应的属性及 deep 作为参数，递归调用 extend 函数，以实现深度复制。 现在，再看看 $.extend 的具体实现 123456789$.extend = function(target) &#123; var deep, args = slice.call(arguments, 1) if (typeof target == 'boolean') &#123; deep = target target = args.shift() &#125; args.forEach(function(arg) &#123; extend(target, arg, deep) &#125;) return target &#125; 在说原理之前，先来看看 $.extend 的调用方式，调用方式如下： 123$.extend(target, [source, [source2, ...]]) 或$.extend(true, target, [source, ...]) 在 $.extend 中，如果不需要深度复制，第一个参数可以是目标对象 target, 后面可以有多个 source 源对象。如果需要深度复制，第一个参数为 deep ，第二个参数为 target ，为目标对象，后面可以有多个 source 源对象。 $.extend 函数的参数设计得很优雅，不需要深度复制时，可以不用显式地将 deep 置为 false。这是如何做到的呢？ 在 $.extend 函数中，定义了一个数组 args，用来接受除第一个参数外的所有参数。 然后判断第一个参数 target 是否为布尔值，如果为布尔值，表示第一个参数为 deep ，那么第二个才为目标对象，因此需要重新为 target 赋值为 args.shift() 。 最后就比较简单了，循环源对象数组 args， 分别调用 extend 方法，实现对目标对象的扩展。 $.each$.each 用来遍历数组或者对象，源码如下： 123456789101112$.each = function(elements, callback) &#123; var i, key if (likeArray(elements)) &#123; // 类数组 for (i = 0; i &lt; elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements &#125; else &#123; // 对象 for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements &#125; return elements &#125; 先来看看调用方式：$.each(collection, function(index, item){ ... }) $.each 接收两个参数，第一个参数 elements 为需要遍历的数组或者对象，第二个 callback 为回调函数。 如果 elements 为数组，用 for 循环，调用 callback ，并且将数组索引 index 和元素值 item 传给回调函数作为参数；如果为对象，用 for···in 遍历属性值，并且将属性 key 及属性值传给回调函数作为参数。 注意回调函数调用了 call 方法，call 的第一个参数为当前元素值或当前属性值，所以回调函数的上下文变成了当前元素值或属性值，也就是说回调函数中的 this 指向的是 item 。这在dom集合的遍历中相当有用。 在遍历的时候，还对回调函数的返回值进行判断，如果回调函数返回 false （if (callback.call(elements[i], i, elements[i]) === false)） ，立即中断遍历。 $.each 调用结束后，会将遍历的数组或对象（ elements ）返回。 $.map可以遍历数组（类数组）或对象中的元素，根据回调函数的返回值，将返回值组成一个新的数组，并将该数组扁平化后返回，会将 null 及 undefined 排除。 123456789101112131415$.map = function(elements, callback) &#123; var value, values = [], i, key if (likeArray(elements)) for (i = 0; i &lt; elements.length; i++) &#123; value = callback(elements[i], i) if (value != null) values.push(value) &#125; else for (key in elements) &#123; value = callback(elements[key], key) if (value != null) values.push(value) &#125; return flatten(values) &#125; 先来看看调用方式： $.map(collection, function(item, index){ ... }) elements 为类数组或者对象。callback 为回调函数。当为类数组时，用 for 循环，当为对象时，用 for···in 循环。并且将对应的元素（属性值）及索引（属性名）传递给回调函数，如果回调函数的返回值不为 null 或者 undefined ，则将返回值存入新数组中，最后将新数组扁平化后返回。 $.camelCase该方法是将字符串转换成驼峰式的字符串 1$.camelCase = camelize $.camelCase 调用的是内部方法 camelize ,该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述，本篇文章就不再展开。 $.contains用来检查给定的父节点中是否包含有给定的子节点，源码如下： 123456789$.contains = document.documentElement.contains ? function(parent, node) &#123; return parent !== node &amp;&amp; parent.contains(node) &#125; : function(parent, node) &#123; while (node &amp;&amp; (node = node.parentNode)) if (node === parent) return true return false &#125; 先来看看调用：$.contains(parent, node) 参数 parent 为父子点，node 为子节点。 $.contains 的主体是一个三元表达式，返回的是一个匿名函数。三元表达式的条件是 document.documentElement.contains， 用来检测浏览器是否支持 contains 方法，如果支持，则直接调用 contains 方法，并且将 parent 和 node 为同一个元素的情况排除。 否则，返回另一外匿名函数。该函数会一直向上寻找 node 元素的父元素，如果能找到跟 parent 相等的父元素，则返回 true， 否则返回 false $.grep该函数其实就是数组的 filter 函数 123$.grep = function(elements, callback) &#123; return filter.call(elements, callback) &#125; 从源码中也可以看出，$.grep 调用的就是数组方法 filter $.inArray返回指定元素在数组中的索引值 123$.inArray = function(elem, array, i) &#123; return emptyArray.indexOf.call(array, elem, i) &#125; 先来看看调用 $.inArray(element, array, [fromIndex]) 第一个参数 element 为指定的元素，第二个参数为 array 为数组， 第三个参数 fromIndex 为可选参数，表示从哪个索引值开始向后查找。 $.inArray 其实调用的是数组的 indexOf 方法，所以传递的参数跟 indexOf 方法一致。 $.isArray判断是否为数组 1$.isArray = isArray $.isArray 调用的是内部方法 isArray ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isFunction判读是否为函数 1$.isFunction = isFunction $.isFunction 调用的是内部方法 isFunction ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isNumeric是否为数值 12345678910$.isNumeric = function(val) &#123; var num = Number(val), // 将参数转换为Number类型 type = typeof val return val != null &amp;&amp; type != 'boolean' &amp;&amp; (type != 'string' || val.length) &amp;&amp; !isNaN(num) &amp;&amp; isFinite(num) || false &#125; 判断是否为数值，需要满足以下条件 不为 null 不为布尔值 不为NaN(当传进来的参数不为数值或如&#39;123&#39;这样形式的字符串时，都会转换成NaN) 为有限数值 当传进来的参数为字符串的形式，如&#39;123&#39; 时，会用到下面这个条件来确保字符串为数字的形式，而不是如 123abc 这样的形式。(type != &#39;string&#39; || val.length) &amp;&amp; !isNaN(num) 。这个条件的包含逻辑如下：如果为字符串类型，并且为字符串的长度大于零，并且转换成数组后的结果不为NaN，则断定为数值。（因为 Number(&#39;&#39;) 的值为 0） $.isPlainObject是否为纯粹对象，即以 {} 常量或 new Object() 创建的对象 1$.isPlainObject = isPlainObject $.isPlainObject 调用的是内部方法isPlainObject ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isWindow是否为浏览器的 window 对象 1$.isWindow = isWindow $.isWindow 调用的是内部方法 isWindow ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.noop空函数 1$.noop = function() &#123;&#125; 这个在需要传递回调函数作为参数，但是又不想在回调函数中做任何事情的时候会非常有用，这时，只需要传递一个空函数即可。 $.parseJSON将标准JSON格式的字符串解释成JSON 1if (window.JSON) $.parseJSON = JSON.parse 其实就是调用原生的 JSON.parse， 并且在浏览器不支持的情况下，zepto 还不提供这个方法。 $.trim删除字符串头尾的空格 123$.trim = function(str) &#123; return str == null ? \"\" : String.prototype.trim.call(str)&#125; 如果参数为 null 或者 undefined ，则直接返回空字符串，否则调用字符串原生的 trim 方法去除头尾的空格。 $.type类型检测 1$.type = type $.type 调用的是内部方法 type ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 能检测的类型有 &quot;Boolean Number String Function Array Date RegExp Object Error&quot; 系列文章 读Zepto源码之代码结构 读 Zepto 源码之内部方法 参考 Zepto中文文档 Node.contains() Array.prototype.indexOf() String.prototype.trim() License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见： 作者：对角另一面","categories":[],"tags":[]},{"title":"读Zepto源码之集合操作","slug":"读Zepto源码之集合操作","date":"2018-04-09T12:50:33.000Z","updated":"2018-05-09T13:59:53.445Z","comments":true,"path":"2018/04/09/读Zepto源码之集合操作/","link":"","permalink":"http://changguo.io/2018/04/09/读Zepto源码之集合操作/","excerpt":"","text":"读Zepto源码之集合操作接下来几个篇章，都会解读 zepto 中的跟 dom 相关的方法，也即源码 $.fn 对象中的方法。 读Zepto源码系列文章已经放到了github上，欢迎star: reading-zepto 源码版本本文阅读的源码为 zepto1.2.0 GitBook《reading-zepto》 .forEach()1forEach: emptyArray.forEach 因为 zepto 的 dom 集合是类数组，所以这里只是简单地复制了数组的 forEach 方法。 具体的 forEach 的用法见文档:Array.prototype.forEach() .reduce()1reduce: emptyArray.reduce 简单地复制了数组的 reduce 方法。 具体的 reduce 的用法见文档:Array.prototype.reduce() .push()1push: emptyArray.push 简单地复制了数组的 push 方法。 具体的 push 的用法见文档:Array.prototype.push() .sort()1sort: emptyArray.sort 简单地复制了数组的 sort 方法。 具体的 sort 的用法见文档:Array.prototype.sort() .splice()1splice: emptyArray.splice 简单地复制了数组的 splice 方法。 具体的 splice 的用法见文档:Array.prototype.splice() .indexOf()1indexOf: emptyArray.indexOf 简单地复制了数组的 indexOf 方法。 具体的 indexOf 的用法见文档:Array.prototype.indexOf() .get()123get: function(idx) &#123; return idx === undefined ? slice.call(this) : this[idx &gt;= 0 ? idx : idx + this.length]&#125;, 这个方法用来获取指定索引值的元素。 不传参（idx === undefined）时，不传参调用数组的 slice 方法，将集合中的所有元素返回。 当传递的参数大于或等于零（idx）时，返回相应索引值的元素 this[idx] ，如果为负数，则倒数返回this.[idx + this.length]。 例如 $(&#39;li&#39;).get(-1) 返回的是倒数第1个元素，也即最后一个元素 .toArray()1toArray: function() &#123; return this.get() &#125; toArray 方法是将元素的类数组变成纯数组。toArray 内部不传参调用 get 方法，上面已经分析了，当不传参数时，get 方法调用的是数组方法 slice， 返回的自然就是纯数组了。 .size()123size: function() &#123; return this.length&#125; size 方法返回的是集合中的 length 属性，也即集合中元素的个数。 .concat()12345678concat: function() &#123; var i, value, args = [] for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value &#125; return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)&#125;, 数组中也有对应的 concat 方法，为什么不能像上面的方法那样直接调用呢？ 这是因为 $.fn 其实是一个类数组对象，并不是真正的数组，如果直接调用 concat 会直接把整个 $.fn 当成数组的一个 item 合并到数组中。 1234for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value&#125; 这段是对每个参数进行判断，如果参数是 zepto 的集合（zepto.isZ(value)），就先调用 toArray 方法，转换成纯数组。 1return concat.apply(zepto.isZ(this) ? this.toArray() : this, args) 这段同样对 this 进行了判断，如果为 zepto 集合，也先转换成数组。所以调用 concat 后返回的是纯数组，不再是 zepto 集合。 .map()123map: function(fn) &#123; return $($.map(this, function(el, i) &#123; return fn.call(el, i, el) &#125;))&#125; map 方法的内部调用的是 zepto 的工具函数 $.map ，这在之前已经在《读Zepto源码之工具函数》做过了分析。 1return fn.call(el, i, el) map 方法对回调也做了包装，call 的第一个参数为 el ，因此可以在 map 的回调中通过 this 来拿到每个元素。 map 方法对 $.map 返回的数组调用了 $() 方法，将返回的数组再次包装成 zepto 对象，因此调用 map 方法后得到的数组，同样具有 zepto 集合中的方法。 .slice()123slice: function() &#123; return $(slice.apply(this, arguments))&#125; slice 同样没有直接用数组的原生方法，也像 map 方法一样，将返回的数组再次包装成 zepto 对象。 .each()123456each: function(callback) &#123; emptyArray.every.call(this, function(el, idx) &#123; return callback.call(el, idx, el) !== false &#125;) return this&#125;, zepto 的 each 方法比较巧妙，在方法内部，调用的其实是数组的 every 方法，every 遇到 false 时就会中止遍历，zepto 也正是利用 every 这种特性，让 each 方法也具有了中止遍历的能力，当 callback 返回的值为布尔值 false 时，中止遍历，注意这里用了 !==，因为 callback 如果没有返回值时，得到的值会是 undefined ，这种情况是需要排除的。 同样，each 的回调中也是可以用 this 拿到每个元素的。 注意，each 方法最后返回的是 this， 所以在 each 调用完后，还可以继续调用 集合中的其他方法，这就是 zepto 的链式调用，这个跟 map 方法中返回 zepto 集合的原理差不多，只不过 each 返回的是跟原来一样的集合，map 方法返回的是映射后的集合。 .add()123add: function(selector, context) &#123; return $(uniq(this.concat($(selector, context))))&#125; add 可以传递两个参数，selector 和 context ，即选择器和上下文。 add 调用 $(selector, context) 来获取符合条件的集合元素，这在上篇文章《读Zepto源码之神奇的$》已经有详细的论述。 然后调用 concat 方法来合并两个集合，用内部方法 uniq 来过滤掉重复的项，uniq 方法在《读Zepto源码之内部方法》已经有论述。最后也是返回一个 zepto 集合。 系列文章 读Zepto源码之代码结构 读 Zepto 源码之内部方法 读Zepto源码之工具函数 读Zepto源码之神奇的$ 参考 Array.prototype.forEach() Array.prototype.reduce() Array.prototype.push() Array.prototype.sort() Array.prototype.splice() Array.prototype.indexOf() License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见： 作者：对角另一面","categories":[],"tags":[]},{"title":"读Zepto源码之集合操作","slug":"读Zepto源码之集合操作的副本 2","date":"2018-04-09T12:50:33.000Z","updated":"2018-05-09T13:59:53.445Z","comments":true,"path":"2018/04/09/读Zepto源码之集合操作的副本 2/","link":"","permalink":"http://changguo.io/2018/04/09/读Zepto源码之集合操作的副本 2/","excerpt":"","text":"读Zepto源码之集合操作接下来几个篇章，都会解读 zepto 中的跟 dom 相关的方法，也即源码 $.fn 对象中的方法。 读Zepto源码系列文章已经放到了github上，欢迎star: reading-zepto 源码版本本文阅读的源码为 zepto1.2.0 GitBook《reading-zepto》 .forEach()1forEach: emptyArray.forEach 因为 zepto 的 dom 集合是类数组，所以这里只是简单地复制了数组的 forEach 方法。 具体的 forEach 的用法见文档:Array.prototype.forEach() .reduce()1reduce: emptyArray.reduce 简单地复制了数组的 reduce 方法。 具体的 reduce 的用法见文档:Array.prototype.reduce() .push()1push: emptyArray.push 简单地复制了数组的 push 方法。 具体的 push 的用法见文档:Array.prototype.push() .sort()1sort: emptyArray.sort 简单地复制了数组的 sort 方法。 具体的 sort 的用法见文档:Array.prototype.sort() .splice()1splice: emptyArray.splice 简单地复制了数组的 splice 方法。 具体的 splice 的用法见文档:Array.prototype.splice() .indexOf()1indexOf: emptyArray.indexOf 简单地复制了数组的 indexOf 方法。 具体的 indexOf 的用法见文档:Array.prototype.indexOf() .get()123get: function(idx) &#123; return idx === undefined ? slice.call(this) : this[idx &gt;= 0 ? idx : idx + this.length]&#125;, 这个方法用来获取指定索引值的元素。 不传参（idx === undefined）时，不传参调用数组的 slice 方法，将集合中的所有元素返回。 当传递的参数大于或等于零（idx）时，返回相应索引值的元素 this[idx] ，如果为负数，则倒数返回this.[idx + this.length]。 例如 $(&#39;li&#39;).get(-1) 返回的是倒数第1个元素，也即最后一个元素 .toArray()1toArray: function() &#123; return this.get() &#125; toArray 方法是将元素的类数组变成纯数组。toArray 内部不传参调用 get 方法，上面已经分析了，当不传参数时，get 方法调用的是数组方法 slice， 返回的自然就是纯数组了。 .size()123size: function() &#123; return this.length&#125; size 方法返回的是集合中的 length 属性，也即集合中元素的个数。 .concat()12345678concat: function() &#123; var i, value, args = [] for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value &#125; return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)&#125;, 数组中也有对应的 concat 方法，为什么不能像上面的方法那样直接调用呢？ 这是因为 $.fn 其实是一个类数组对象，并不是真正的数组，如果直接调用 concat 会直接把整个 $.fn 当成数组的一个 item 合并到数组中。 1234for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value&#125; 这段是对每个参数进行判断，如果参数是 zepto 的集合（zepto.isZ(value)），就先调用 toArray 方法，转换成纯数组。 1return concat.apply(zepto.isZ(this) ? this.toArray() : this, args) 这段同样对 this 进行了判断，如果为 zepto 集合，也先转换成数组。所以调用 concat 后返回的是纯数组，不再是 zepto 集合。 .map()123map: function(fn) &#123; return $($.map(this, function(el, i) &#123; return fn.call(el, i, el) &#125;))&#125; map 方法的内部调用的是 zepto 的工具函数 $.map ，这在之前已经在《读Zepto源码之工具函数》做过了分析。 1return fn.call(el, i, el) map 方法对回调也做了包装，call 的第一个参数为 el ，因此可以在 map 的回调中通过 this 来拿到每个元素。 map 方法对 $.map 返回的数组调用了 $() 方法，将返回的数组再次包装成 zepto 对象，因此调用 map 方法后得到的数组，同样具有 zepto 集合中的方法。 .slice()123slice: function() &#123; return $(slice.apply(this, arguments))&#125; slice 同样没有直接用数组的原生方法，也像 map 方法一样，将返回的数组再次包装成 zepto 对象。 .each()123456each: function(callback) &#123; emptyArray.every.call(this, function(el, idx) &#123; return callback.call(el, idx, el) !== false &#125;) return this&#125;, zepto 的 each 方法比较巧妙，在方法内部，调用的其实是数组的 every 方法，every 遇到 false 时就会中止遍历，zepto 也正是利用 every 这种特性，让 each 方法也具有了中止遍历的能力，当 callback 返回的值为布尔值 false 时，中止遍历，注意这里用了 !==，因为 callback 如果没有返回值时，得到的值会是 undefined ，这种情况是需要排除的。 同样，each 的回调中也是可以用 this 拿到每个元素的。 注意，each 方法最后返回的是 this， 所以在 each 调用完后，还可以继续调用 集合中的其他方法，这就是 zepto 的链式调用，这个跟 map 方法中返回 zepto 集合的原理差不多，只不过 each 返回的是跟原来一样的集合，map 方法返回的是映射后的集合。 .add()123add: function(selector, context) &#123; return $(uniq(this.concat($(selector, context))))&#125; add 可以传递两个参数，selector 和 context ，即选择器和上下文。 add 调用 $(selector, context) 来获取符合条件的集合元素，这在上篇文章《读Zepto源码之神奇的$》已经有详细的论述。 然后调用 concat 方法来合并两个集合，用内部方法 uniq 来过滤掉重复的项，uniq 方法在《读Zepto源码之内部方法》已经有论述。最后也是返回一个 zepto 集合。 系列文章 读Zepto源码之代码结构 读 Zepto 源码之内部方法 读Zepto源码之工具函数 读Zepto源码之神奇的$ 参考 Array.prototype.forEach() Array.prototype.reduce() Array.prototype.push() Array.prototype.sort() Array.prototype.splice() Array.prototype.indexOf() License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见： 作者：对角另一面","categories":[],"tags":[]},{"title":"读Zepto源码之集合操作","slug":"读Zepto源码之集合操作的副本 3","date":"2018-04-09T12:50:33.000Z","updated":"2018-05-09T13:59:53.445Z","comments":true,"path":"2018/04/09/读Zepto源码之集合操作的副本 3/","link":"","permalink":"http://changguo.io/2018/04/09/读Zepto源码之集合操作的副本 3/","excerpt":"","text":"读Zepto源码之集合操作接下来几个篇章，都会解读 zepto 中的跟 dom 相关的方法，也即源码 $.fn 对象中的方法。 读Zepto源码系列文章已经放到了github上，欢迎star: reading-zepto 源码版本本文阅读的源码为 zepto1.2.0 GitBook《reading-zepto》 .forEach()1forEach: emptyArray.forEach 因为 zepto 的 dom 集合是类数组，所以这里只是简单地复制了数组的 forEach 方法。 具体的 forEach 的用法见文档:Array.prototype.forEach() .reduce()1reduce: emptyArray.reduce 简单地复制了数组的 reduce 方法。 具体的 reduce 的用法见文档:Array.prototype.reduce() .push()1push: emptyArray.push 简单地复制了数组的 push 方法。 具体的 push 的用法见文档:Array.prototype.push() .sort()1sort: emptyArray.sort 简单地复制了数组的 sort 方法。 具体的 sort 的用法见文档:Array.prototype.sort() .splice()1splice: emptyArray.splice 简单地复制了数组的 splice 方法。 具体的 splice 的用法见文档:Array.prototype.splice() .indexOf()1indexOf: emptyArray.indexOf 简单地复制了数组的 indexOf 方法。 具体的 indexOf 的用法见文档:Array.prototype.indexOf() .get()123get: function(idx) &#123; return idx === undefined ? slice.call(this) : this[idx &gt;= 0 ? idx : idx + this.length]&#125;, 这个方法用来获取指定索引值的元素。 不传参（idx === undefined）时，不传参调用数组的 slice 方法，将集合中的所有元素返回。 当传递的参数大于或等于零（idx）时，返回相应索引值的元素 this[idx] ，如果为负数，则倒数返回this.[idx + this.length]。 例如 $(&#39;li&#39;).get(-1) 返回的是倒数第1个元素，也即最后一个元素 .toArray()1toArray: function() &#123; return this.get() &#125; toArray 方法是将元素的类数组变成纯数组。toArray 内部不传参调用 get 方法，上面已经分析了，当不传参数时，get 方法调用的是数组方法 slice， 返回的自然就是纯数组了。 .size()123size: function() &#123; return this.length&#125; size 方法返回的是集合中的 length 属性，也即集合中元素的个数。 .concat()12345678concat: function() &#123; var i, value, args = [] for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value &#125; return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)&#125;, 数组中也有对应的 concat 方法，为什么不能像上面的方法那样直接调用呢？ 这是因为 $.fn 其实是一个类数组对象，并不是真正的数组，如果直接调用 concat 会直接把整个 $.fn 当成数组的一个 item 合并到数组中。 1234for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value&#125; 这段是对每个参数进行判断，如果参数是 zepto 的集合（zepto.isZ(value)），就先调用 toArray 方法，转换成纯数组。 1return concat.apply(zepto.isZ(this) ? this.toArray() : this, args) 这段同样对 this 进行了判断，如果为 zepto 集合，也先转换成数组。所以调用 concat 后返回的是纯数组，不再是 zepto 集合。 .map()123map: function(fn) &#123; return $($.map(this, function(el, i) &#123; return fn.call(el, i, el) &#125;))&#125; map 方法的内部调用的是 zepto 的工具函数 $.map ，这在之前已经在《读Zepto源码之工具函数》做过了分析。 1return fn.call(el, i, el) map 方法对回调也做了包装，call 的第一个参数为 el ，因此可以在 map 的回调中通过 this 来拿到每个元素。 map 方法对 $.map 返回的数组调用了 $() 方法，将返回的数组再次包装成 zepto 对象，因此调用 map 方法后得到的数组，同样具有 zepto 集合中的方法。 .slice()123slice: function() &#123; return $(slice.apply(this, arguments))&#125; slice 同样没有直接用数组的原生方法，也像 map 方法一样，将返回的数组再次包装成 zepto 对象。 .each()123456each: function(callback) &#123; emptyArray.every.call(this, function(el, idx) &#123; return callback.call(el, idx, el) !== false &#125;) return this&#125;, zepto 的 each 方法比较巧妙，在方法内部，调用的其实是数组的 every 方法，every 遇到 false 时就会中止遍历，zepto 也正是利用 every 这种特性，让 each 方法也具有了中止遍历的能力，当 callback 返回的值为布尔值 false 时，中止遍历，注意这里用了 !==，因为 callback 如果没有返回值时，得到的值会是 undefined ，这种情况是需要排除的。 同样，each 的回调中也是可以用 this 拿到每个元素的。 注意，each 方法最后返回的是 this， 所以在 each 调用完后，还可以继续调用 集合中的其他方法，这就是 zepto 的链式调用，这个跟 map 方法中返回 zepto 集合的原理差不多，只不过 each 返回的是跟原来一样的集合，map 方法返回的是映射后的集合。 .add()123add: function(selector, context) &#123; return $(uniq(this.concat($(selector, context))))&#125; add 可以传递两个参数，selector 和 context ，即选择器和上下文。 add 调用 $(selector, context) 来获取符合条件的集合元素，这在上篇文章《读Zepto源码之神奇的$》已经有详细的论述。 然后调用 concat 方法来合并两个集合，用内部方法 uniq 来过滤掉重复的项，uniq 方法在《读Zepto源码之内部方法》已经有论述。最后也是返回一个 zepto 集合。 系列文章 读Zepto源码之代码结构 读 Zepto 源码之内部方法 读Zepto源码之工具函数 读Zepto源码之神奇的$ 参考 Array.prototype.forEach() Array.prototype.reduce() Array.prototype.push() Array.prototype.sort() Array.prototype.splice() Array.prototype.indexOf() License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见： 作者：对角另一面","categories":[],"tags":[]},{"title":"读Zepto源码之集合操作","slug":"读Zepto源码之集合操作的副本 4","date":"2018-04-09T12:50:33.000Z","updated":"2018-05-09T13:59:53.445Z","comments":true,"path":"2018/04/09/读Zepto源码之集合操作的副本 4/","link":"","permalink":"http://changguo.io/2018/04/09/读Zepto源码之集合操作的副本 4/","excerpt":"","text":"读Zepto源码之集合操作接下来几个篇章，都会解读 zepto 中的跟 dom 相关的方法，也即源码 $.fn 对象中的方法。 读Zepto源码系列文章已经放到了github上，欢迎star: reading-zepto 源码版本本文阅读的源码为 zepto1.2.0 GitBook《reading-zepto》 .forEach()1forEach: emptyArray.forEach 因为 zepto 的 dom 集合是类数组，所以这里只是简单地复制了数组的 forEach 方法。 具体的 forEach 的用法见文档:Array.prototype.forEach() .reduce()1reduce: emptyArray.reduce 简单地复制了数组的 reduce 方法。 具体的 reduce 的用法见文档:Array.prototype.reduce() .push()1push: emptyArray.push 简单地复制了数组的 push 方法。 具体的 push 的用法见文档:Array.prototype.push() .sort()1sort: emptyArray.sort 简单地复制了数组的 sort 方法。 具体的 sort 的用法见文档:Array.prototype.sort() .splice()1splice: emptyArray.splice 简单地复制了数组的 splice 方法。 具体的 splice 的用法见文档:Array.prototype.splice() .indexOf()1indexOf: emptyArray.indexOf 简单地复制了数组的 indexOf 方法。 具体的 indexOf 的用法见文档:Array.prototype.indexOf() .get()123get: function(idx) &#123; return idx === undefined ? slice.call(this) : this[idx &gt;= 0 ? idx : idx + this.length]&#125;, 这个方法用来获取指定索引值的元素。 不传参（idx === undefined）时，不传参调用数组的 slice 方法，将集合中的所有元素返回。 当传递的参数大于或等于零（idx）时，返回相应索引值的元素 this[idx] ，如果为负数，则倒数返回this.[idx + this.length]。 例如 $(&#39;li&#39;).get(-1) 返回的是倒数第1个元素，也即最后一个元素 .toArray()1toArray: function() &#123; return this.get() &#125; toArray 方法是将元素的类数组变成纯数组。toArray 内部不传参调用 get 方法，上面已经分析了，当不传参数时，get 方法调用的是数组方法 slice， 返回的自然就是纯数组了。 .size()123size: function() &#123; return this.length&#125; size 方法返回的是集合中的 length 属性，也即集合中元素的个数。 .concat()12345678concat: function() &#123; var i, value, args = [] for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value &#125; return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)&#125;, 数组中也有对应的 concat 方法，为什么不能像上面的方法那样直接调用呢？ 这是因为 $.fn 其实是一个类数组对象，并不是真正的数组，如果直接调用 concat 会直接把整个 $.fn 当成数组的一个 item 合并到数组中。 1234for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value&#125; 这段是对每个参数进行判断，如果参数是 zepto 的集合（zepto.isZ(value)），就先调用 toArray 方法，转换成纯数组。 1return concat.apply(zepto.isZ(this) ? this.toArray() : this, args) 这段同样对 this 进行了判断，如果为 zepto 集合，也先转换成数组。所以调用 concat 后返回的是纯数组，不再是 zepto 集合。 .map()123map: function(fn) &#123; return $($.map(this, function(el, i) &#123; return fn.call(el, i, el) &#125;))&#125; map 方法的内部调用的是 zepto 的工具函数 $.map ，这在之前已经在《读Zepto源码之工具函数》做过了分析。 1return fn.call(el, i, el) map 方法对回调也做了包装，call 的第一个参数为 el ，因此可以在 map 的回调中通过 this 来拿到每个元素。 map 方法对 $.map 返回的数组调用了 $() 方法，将返回的数组再次包装成 zepto 对象，因此调用 map 方法后得到的数组，同样具有 zepto 集合中的方法。 .slice()123slice: function() &#123; return $(slice.apply(this, arguments))&#125; slice 同样没有直接用数组的原生方法，也像 map 方法一样，将返回的数组再次包装成 zepto 对象。 .each()123456each: function(callback) &#123; emptyArray.every.call(this, function(el, idx) &#123; return callback.call(el, idx, el) !== false &#125;) return this&#125;, zepto 的 each 方法比较巧妙，在方法内部，调用的其实是数组的 every 方法，every 遇到 false 时就会中止遍历，zepto 也正是利用 every 这种特性，让 each 方法也具有了中止遍历的能力，当 callback 返回的值为布尔值 false 时，中止遍历，注意这里用了 !==，因为 callback 如果没有返回值时，得到的值会是 undefined ，这种情况是需要排除的。 同样，each 的回调中也是可以用 this 拿到每个元素的。 注意，each 方法最后返回的是 this， 所以在 each 调用完后，还可以继续调用 集合中的其他方法，这就是 zepto 的链式调用，这个跟 map 方法中返回 zepto 集合的原理差不多，只不过 each 返回的是跟原来一样的集合，map 方法返回的是映射后的集合。 .add()123add: function(selector, context) &#123; return $(uniq(this.concat($(selector, context))))&#125; add 可以传递两个参数，selector 和 context ，即选择器和上下文。 add 调用 $(selector, context) 来获取符合条件的集合元素，这在上篇文章《读Zepto源码之神奇的$》已经有详细的论述。 然后调用 concat 方法来合并两个集合，用内部方法 uniq 来过滤掉重复的项，uniq 方法在《读Zepto源码之内部方法》已经有论述。最后也是返回一个 zepto 集合。 系列文章 读Zepto源码之代码结构 读 Zepto 源码之内部方法 读Zepto源码之工具函数 读Zepto源码之神奇的$ 参考 Array.prototype.forEach() Array.prototype.reduce() Array.prototype.push() Array.prototype.sort() Array.prototype.splice() Array.prototype.indexOf() License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见： 作者：对角另一面","categories":[],"tags":[]},{"title":"读Zepto源码之集合操作","slug":"读Zepto源码之集合操作的副本 5","date":"2018-04-09T12:50:33.000Z","updated":"2018-05-09T13:59:53.445Z","comments":true,"path":"2018/04/09/读Zepto源码之集合操作的副本 5/","link":"","permalink":"http://changguo.io/2018/04/09/读Zepto源码之集合操作的副本 5/","excerpt":"","text":"读Zepto源码之集合操作接下来几个篇章，都会解读 zepto 中的跟 dom 相关的方法，也即源码 $.fn 对象中的方法。 读Zepto源码系列文章已经放到了github上，欢迎star: reading-zepto 源码版本本文阅读的源码为 zepto1.2.0 GitBook《reading-zepto》 .forEach()1forEach: emptyArray.forEach 因为 zepto 的 dom 集合是类数组，所以这里只是简单地复制了数组的 forEach 方法。 具体的 forEach 的用法见文档:Array.prototype.forEach() .reduce()1reduce: emptyArray.reduce 简单地复制了数组的 reduce 方法。 具体的 reduce 的用法见文档:Array.prototype.reduce() .push()1push: emptyArray.push 简单地复制了数组的 push 方法。 具体的 push 的用法见文档:Array.prototype.push() .sort()1sort: emptyArray.sort 简单地复制了数组的 sort 方法。 具体的 sort 的用法见文档:Array.prototype.sort() .splice()1splice: emptyArray.splice 简单地复制了数组的 splice 方法。 具体的 splice 的用法见文档:Array.prototype.splice() .indexOf()1indexOf: emptyArray.indexOf 简单地复制了数组的 indexOf 方法。 具体的 indexOf 的用法见文档:Array.prototype.indexOf() .get()123get: function(idx) &#123; return idx === undefined ? slice.call(this) : this[idx &gt;= 0 ? idx : idx + this.length]&#125;, 这个方法用来获取指定索引值的元素。 不传参（idx === undefined）时，不传参调用数组的 slice 方法，将集合中的所有元素返回。 当传递的参数大于或等于零（idx）时，返回相应索引值的元素 this[idx] ，如果为负数，则倒数返回this.[idx + this.length]。 例如 $(&#39;li&#39;).get(-1) 返回的是倒数第1个元素，也即最后一个元素 .toArray()1toArray: function() &#123; return this.get() &#125; toArray 方法是将元素的类数组变成纯数组。toArray 内部不传参调用 get 方法，上面已经分析了，当不传参数时，get 方法调用的是数组方法 slice， 返回的自然就是纯数组了。 .size()123size: function() &#123; return this.length&#125; size 方法返回的是集合中的 length 属性，也即集合中元素的个数。 .concat()12345678concat: function() &#123; var i, value, args = [] for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value &#125; return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)&#125;, 数组中也有对应的 concat 方法，为什么不能像上面的方法那样直接调用呢？ 这是因为 $.fn 其实是一个类数组对象，并不是真正的数组，如果直接调用 concat 会直接把整个 $.fn 当成数组的一个 item 合并到数组中。 1234for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value&#125; 这段是对每个参数进行判断，如果参数是 zepto 的集合（zepto.isZ(value)），就先调用 toArray 方法，转换成纯数组。 1return concat.apply(zepto.isZ(this) ? this.toArray() : this, args) 这段同样对 this 进行了判断，如果为 zepto 集合，也先转换成数组。所以调用 concat 后返回的是纯数组，不再是 zepto 集合。 .map()123map: function(fn) &#123; return $($.map(this, function(el, i) &#123; return fn.call(el, i, el) &#125;))&#125; map 方法的内部调用的是 zepto 的工具函数 $.map ，这在之前已经在《读Zepto源码之工具函数》做过了分析。 1return fn.call(el, i, el) map 方法对回调也做了包装，call 的第一个参数为 el ，因此可以在 map 的回调中通过 this 来拿到每个元素。 map 方法对 $.map 返回的数组调用了 $() 方法，将返回的数组再次包装成 zepto 对象，因此调用 map 方法后得到的数组，同样具有 zepto 集合中的方法。 .slice()123slice: function() &#123; return $(slice.apply(this, arguments))&#125; slice 同样没有直接用数组的原生方法，也像 map 方法一样，将返回的数组再次包装成 zepto 对象。 .each()123456each: function(callback) &#123; emptyArray.every.call(this, function(el, idx) &#123; return callback.call(el, idx, el) !== false &#125;) return this&#125;, zepto 的 each 方法比较巧妙，在方法内部，调用的其实是数组的 every 方法，every 遇到 false 时就会中止遍历，zepto 也正是利用 every 这种特性，让 each 方法也具有了中止遍历的能力，当 callback 返回的值为布尔值 false 时，中止遍历，注意这里用了 !==，因为 callback 如果没有返回值时，得到的值会是 undefined ，这种情况是需要排除的。 同样，each 的回调中也是可以用 this 拿到每个元素的。 注意，each 方法最后返回的是 this， 所以在 each 调用完后，还可以继续调用 集合中的其他方法，这就是 zepto 的链式调用，这个跟 map 方法中返回 zepto 集合的原理差不多，只不过 each 返回的是跟原来一样的集合，map 方法返回的是映射后的集合。 .add()123add: function(selector, context) &#123; return $(uniq(this.concat($(selector, context))))&#125; add 可以传递两个参数，selector 和 context ，即选择器和上下文。 add 调用 $(selector, context) 来获取符合条件的集合元素，这在上篇文章《读Zepto源码之神奇的$》已经有详细的论述。 然后调用 concat 方法来合并两个集合，用内部方法 uniq 来过滤掉重复的项，uniq 方法在《读Zepto源码之内部方法》已经有论述。最后也是返回一个 zepto 集合。 系列文章 读Zepto源码之代码结构 读 Zepto 源码之内部方法 读Zepto源码之工具函数 读Zepto源码之神奇的$ 参考 Array.prototype.forEach() Array.prototype.reduce() Array.prototype.push() Array.prototype.sort() Array.prototype.splice() Array.prototype.indexOf() License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见： 作者：对角另一面","categories":[],"tags":[]},{"title":"读Zepto源码之集合操作","slug":"读Zepto源码之集合操作的副本 6","date":"2018-04-09T12:50:33.000Z","updated":"2018-05-09T13:59:53.445Z","comments":true,"path":"2018/04/09/读Zepto源码之集合操作的副本 6/","link":"","permalink":"http://changguo.io/2018/04/09/读Zepto源码之集合操作的副本 6/","excerpt":"","text":"读Zepto源码之集合操作接下来几个篇章，都会解读 zepto 中的跟 dom 相关的方法，也即源码 $.fn 对象中的方法。 读Zepto源码系列文章已经放到了github上，欢迎star: reading-zepto 源码版本本文阅读的源码为 zepto1.2.0 GitBook《reading-zepto》 .forEach()1forEach: emptyArray.forEach 因为 zepto 的 dom 集合是类数组，所以这里只是简单地复制了数组的 forEach 方法。 具体的 forEach 的用法见文档:Array.prototype.forEach() .reduce()1reduce: emptyArray.reduce 简单地复制了数组的 reduce 方法。 具体的 reduce 的用法见文档:Array.prototype.reduce() .push()1push: emptyArray.push 简单地复制了数组的 push 方法。 具体的 push 的用法见文档:Array.prototype.push() .sort()1sort: emptyArray.sort 简单地复制了数组的 sort 方法。 具体的 sort 的用法见文档:Array.prototype.sort() .splice()1splice: emptyArray.splice 简单地复制了数组的 splice 方法。 具体的 splice 的用法见文档:Array.prototype.splice() .indexOf()1indexOf: emptyArray.indexOf 简单地复制了数组的 indexOf 方法。 具体的 indexOf 的用法见文档:Array.prototype.indexOf() .get()123get: function(idx) &#123; return idx === undefined ? slice.call(this) : this[idx &gt;= 0 ? idx : idx + this.length]&#125;, 这个方法用来获取指定索引值的元素。 不传参（idx === undefined）时，不传参调用数组的 slice 方法，将集合中的所有元素返回。 当传递的参数大于或等于零（idx）时，返回相应索引值的元素 this[idx] ，如果为负数，则倒数返回this.[idx + this.length]。 例如 $(&#39;li&#39;).get(-1) 返回的是倒数第1个元素，也即最后一个元素 .toArray()1toArray: function() &#123; return this.get() &#125; toArray 方法是将元素的类数组变成纯数组。toArray 内部不传参调用 get 方法，上面已经分析了，当不传参数时，get 方法调用的是数组方法 slice， 返回的自然就是纯数组了。 .size()123size: function() &#123; return this.length&#125; size 方法返回的是集合中的 length 属性，也即集合中元素的个数。 .concat()12345678concat: function() &#123; var i, value, args = [] for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value &#125; return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)&#125;, 数组中也有对应的 concat 方法，为什么不能像上面的方法那样直接调用呢？ 这是因为 $.fn 其实是一个类数组对象，并不是真正的数组，如果直接调用 concat 会直接把整个 $.fn 当成数组的一个 item 合并到数组中。 1234for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value&#125; 这段是对每个参数进行判断，如果参数是 zepto 的集合（zepto.isZ(value)），就先调用 toArray 方法，转换成纯数组。 1return concat.apply(zepto.isZ(this) ? this.toArray() : this, args) 这段同样对 this 进行了判断，如果为 zepto 集合，也先转换成数组。所以调用 concat 后返回的是纯数组，不再是 zepto 集合。 .map()123map: function(fn) &#123; return $($.map(this, function(el, i) &#123; return fn.call(el, i, el) &#125;))&#125; map 方法的内部调用的是 zepto 的工具函数 $.map ，这在之前已经在《读Zepto源码之工具函数》做过了分析。 1return fn.call(el, i, el) map 方法对回调也做了包装，call 的第一个参数为 el ，因此可以在 map 的回调中通过 this 来拿到每个元素。 map 方法对 $.map 返回的数组调用了 $() 方法，将返回的数组再次包装成 zepto 对象，因此调用 map 方法后得到的数组，同样具有 zepto 集合中的方法。 .slice()123slice: function() &#123; return $(slice.apply(this, arguments))&#125; slice 同样没有直接用数组的原生方法，也像 map 方法一样，将返回的数组再次包装成 zepto 对象。 .each()123456each: function(callback) &#123; emptyArray.every.call(this, function(el, idx) &#123; return callback.call(el, idx, el) !== false &#125;) return this&#125;, zepto 的 each 方法比较巧妙，在方法内部，调用的其实是数组的 every 方法，every 遇到 false 时就会中止遍历，zepto 也正是利用 every 这种特性，让 each 方法也具有了中止遍历的能力，当 callback 返回的值为布尔值 false 时，中止遍历，注意这里用了 !==，因为 callback 如果没有返回值时，得到的值会是 undefined ，这种情况是需要排除的。 同样，each 的回调中也是可以用 this 拿到每个元素的。 注意，each 方法最后返回的是 this， 所以在 each 调用完后，还可以继续调用 集合中的其他方法，这就是 zepto 的链式调用，这个跟 map 方法中返回 zepto 集合的原理差不多，只不过 each 返回的是跟原来一样的集合，map 方法返回的是映射后的集合。 .add()123add: function(selector, context) &#123; return $(uniq(this.concat($(selector, context))))&#125; add 可以传递两个参数，selector 和 context ，即选择器和上下文。 add 调用 $(selector, context) 来获取符合条件的集合元素，这在上篇文章《读Zepto源码之神奇的$》已经有详细的论述。 然后调用 concat 方法来合并两个集合，用内部方法 uniq 来过滤掉重复的项，uniq 方法在《读Zepto源码之内部方法》已经有论述。最后也是返回一个 zepto 集合。 系列文章 读Zepto源码之代码结构 读 Zepto 源码之内部方法 读Zepto源码之工具函数 读Zepto源码之神奇的$ 参考 Array.prototype.forEach() Array.prototype.reduce() Array.prototype.push() Array.prototype.sort() Array.prototype.splice() Array.prototype.indexOf() License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见： 作者：对角另一面","categories":[],"tags":[]},{"title":"读Zepto源码之集合操作","slug":"读Zepto源码之集合操作的副本 7","date":"2018-04-09T12:50:33.000Z","updated":"2018-05-09T13:59:53.445Z","comments":true,"path":"2018/04/09/读Zepto源码之集合操作的副本 7/","link":"","permalink":"http://changguo.io/2018/04/09/读Zepto源码之集合操作的副本 7/","excerpt":"","text":"读Zepto源码之集合操作接下来几个篇章，都会解读 zepto 中的跟 dom 相关的方法，也即源码 $.fn 对象中的方法。 读Zepto源码系列文章已经放到了github上，欢迎star: reading-zepto 源码版本本文阅读的源码为 zepto1.2.0 GitBook《reading-zepto》 .forEach()1forEach: emptyArray.forEach 因为 zepto 的 dom 集合是类数组，所以这里只是简单地复制了数组的 forEach 方法。 具体的 forEach 的用法见文档:Array.prototype.forEach() .reduce()1reduce: emptyArray.reduce 简单地复制了数组的 reduce 方法。 具体的 reduce 的用法见文档:Array.prototype.reduce() .push()1push: emptyArray.push 简单地复制了数组的 push 方法。 具体的 push 的用法见文档:Array.prototype.push() .sort()1sort: emptyArray.sort 简单地复制了数组的 sort 方法。 具体的 sort 的用法见文档:Array.prototype.sort() .splice()1splice: emptyArray.splice 简单地复制了数组的 splice 方法。 具体的 splice 的用法见文档:Array.prototype.splice() .indexOf()1indexOf: emptyArray.indexOf 简单地复制了数组的 indexOf 方法。 具体的 indexOf 的用法见文档:Array.prototype.indexOf() .get()123get: function(idx) &#123; return idx === undefined ? slice.call(this) : this[idx &gt;= 0 ? idx : idx + this.length]&#125;, 这个方法用来获取指定索引值的元素。 不传参（idx === undefined）时，不传参调用数组的 slice 方法，将集合中的所有元素返回。 当传递的参数大于或等于零（idx）时，返回相应索引值的元素 this[idx] ，如果为负数，则倒数返回this.[idx + this.length]。 例如 $(&#39;li&#39;).get(-1) 返回的是倒数第1个元素，也即最后一个元素 .toArray()1toArray: function() &#123; return this.get() &#125; toArray 方法是将元素的类数组变成纯数组。toArray 内部不传参调用 get 方法，上面已经分析了，当不传参数时，get 方法调用的是数组方法 slice， 返回的自然就是纯数组了。 .size()123size: function() &#123; return this.length&#125; size 方法返回的是集合中的 length 属性，也即集合中元素的个数。 .concat()12345678concat: function() &#123; var i, value, args = [] for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value &#125; return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)&#125;, 数组中也有对应的 concat 方法，为什么不能像上面的方法那样直接调用呢？ 这是因为 $.fn 其实是一个类数组对象，并不是真正的数组，如果直接调用 concat 会直接把整个 $.fn 当成数组的一个 item 合并到数组中。 1234for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value&#125; 这段是对每个参数进行判断，如果参数是 zepto 的集合（zepto.isZ(value)），就先调用 toArray 方法，转换成纯数组。 1return concat.apply(zepto.isZ(this) ? this.toArray() : this, args) 这段同样对 this 进行了判断，如果为 zepto 集合，也先转换成数组。所以调用 concat 后返回的是纯数组，不再是 zepto 集合。 .map()123map: function(fn) &#123; return $($.map(this, function(el, i) &#123; return fn.call(el, i, el) &#125;))&#125; map 方法的内部调用的是 zepto 的工具函数 $.map ，这在之前已经在《读Zepto源码之工具函数》做过了分析。 1return fn.call(el, i, el) map 方法对回调也做了包装，call 的第一个参数为 el ，因此可以在 map 的回调中通过 this 来拿到每个元素。 map 方法对 $.map 返回的数组调用了 $() 方法，将返回的数组再次包装成 zepto 对象，因此调用 map 方法后得到的数组，同样具有 zepto 集合中的方法。 .slice()123slice: function() &#123; return $(slice.apply(this, arguments))&#125; slice 同样没有直接用数组的原生方法，也像 map 方法一样，将返回的数组再次包装成 zepto 对象。 .each()123456each: function(callback) &#123; emptyArray.every.call(this, function(el, idx) &#123; return callback.call(el, idx, el) !== false &#125;) return this&#125;, zepto 的 each 方法比较巧妙，在方法内部，调用的其实是数组的 every 方法，every 遇到 false 时就会中止遍历，zepto 也正是利用 every 这种特性，让 each 方法也具有了中止遍历的能力，当 callback 返回的值为布尔值 false 时，中止遍历，注意这里用了 !==，因为 callback 如果没有返回值时，得到的值会是 undefined ，这种情况是需要排除的。 同样，each 的回调中也是可以用 this 拿到每个元素的。 注意，each 方法最后返回的是 this， 所以在 each 调用完后，还可以继续调用 集合中的其他方法，这就是 zepto 的链式调用，这个跟 map 方法中返回 zepto 集合的原理差不多，只不过 each 返回的是跟原来一样的集合，map 方法返回的是映射后的集合。 .add()123add: function(selector, context) &#123; return $(uniq(this.concat($(selector, context))))&#125; add 可以传递两个参数，selector 和 context ，即选择器和上下文。 add 调用 $(selector, context) 来获取符合条件的集合元素，这在上篇文章《读Zepto源码之神奇的$》已经有详细的论述。 然后调用 concat 方法来合并两个集合，用内部方法 uniq 来过滤掉重复的项，uniq 方法在《读Zepto源码之内部方法》已经有论述。最后也是返回一个 zepto 集合。 系列文章 读Zepto源码之代码结构 读 Zepto 源码之内部方法 读Zepto源码之工具函数 读Zepto源码之神奇的$ 参考 Array.prototype.forEach() Array.prototype.reduce() Array.prototype.push() Array.prototype.sort() Array.prototype.splice() Array.prototype.indexOf() License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见： 作者：对角另一面","categories":[],"tags":[]},{"title":"读zepto源码之工具函数","slug":"读Zepto源码之工具函数的副本 5","date":"2018-04-09T12:50:33.000Z","updated":"2018-05-09T13:59:13.966Z","comments":true,"path":"2018/04/09/读Zepto源码之工具函数的副本 5/","link":"","permalink":"http://changguo.io/2018/04/09/读Zepto源码之工具函数的副本 5/","excerpt":"","text":"读zepto源码之工具函数Zepto 提供了丰富的工具函数，下面来一一解读。 源码版本本文阅读的源码为 zepto1.2.0 GitBook《reading-zepto》 $.extend$.extend 方法可以用来扩展目标对象的属性。目标对象的同名属性会被源对象的属性覆盖。 $.extend 其实调用的是内部方法 extend， 所以我们先看看内部方法 extend 的具体实现。 12345678910function extend(target, source, deep) &#123; for (key in source) // 遍历源对象的属性值 if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123; // 如果为深度复制，并且源对象的属性值为纯粹对象或者数组 if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) // 如果为纯粹对象 target[key] = &#123;&#125; // 如果源对象的属性值为纯粹对象，并且目标对象对应的属性值不为纯粹对象，则将目标对象对应的属性值置为空对象 if (isArray(source[key]) &amp;&amp; !isArray(target[key])) // 如果源对象的属性值为数组，并且目标对象对应的属性值不为数组，则将目标对象对应的属性值置为空数组 target[key] = [] extend(target[key], source[key], deep) // 递归调用extend函数 &#125; else if (source[key] !== undefined) target[key] = source[key] // 不对undefined值进行复制 &#125; extend 的第一个参数 taget 为目标对象， source 为源对象， deep 表示是否为深度复制。当 deep 为 true 时为深度复制， false 时为浅复制。 extend 函数用 for···in 对 source 的属性进行遍历 如果 deep 为 false 时，只进行浅复制，将 source 中不为 undefined 的值赋值到 target 对应的属性中（注意，这里用的是 !==，不是 != ，所以只排除严格为 undefined 的值，不包含 null ）。如果 source 对应的属性值为对象或者数组，会保持该对象或数组的引用。 如果 deep 为 true ，并且 source 的属性值为纯粹对象或者数组时 3.1. 如果 source 的属性为纯粹对象，并且 target 对应的属性不为纯粹对象时，将 target 的对应属性设置为空对象 3.2. 如果 source 的属性为数组，并且 target 对应属性不为数组时，将 target 的对应属性设置为空数组 3.3. 将 source 和 target 对应的属性及 deep 作为参数，递归调用 extend 函数，以实现深度复制。 现在，再看看 $.extend 的具体实现 123456789$.extend = function(target) &#123; var deep, args = slice.call(arguments, 1) if (typeof target == 'boolean') &#123; deep = target target = args.shift() &#125; args.forEach(function(arg) &#123; extend(target, arg, deep) &#125;) return target &#125; 在说原理之前，先来看看 $.extend 的调用方式，调用方式如下： 123$.extend(target, [source, [source2, ...]]) 或$.extend(true, target, [source, ...]) 在 $.extend 中，如果不需要深度复制，第一个参数可以是目标对象 target, 后面可以有多个 source 源对象。如果需要深度复制，第一个参数为 deep ，第二个参数为 target ，为目标对象，后面可以有多个 source 源对象。 $.extend 函数的参数设计得很优雅，不需要深度复制时，可以不用显式地将 deep 置为 false。这是如何做到的呢？ 在 $.extend 函数中，定义了一个数组 args，用来接受除第一个参数外的所有参数。 然后判断第一个参数 target 是否为布尔值，如果为布尔值，表示第一个参数为 deep ，那么第二个才为目标对象，因此需要重新为 target 赋值为 args.shift() 。 最后就比较简单了，循环源对象数组 args， 分别调用 extend 方法，实现对目标对象的扩展。 $.each$.each 用来遍历数组或者对象，源码如下： 123456789101112$.each = function(elements, callback) &#123; var i, key if (likeArray(elements)) &#123; // 类数组 for (i = 0; i &lt; elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements &#125; else &#123; // 对象 for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements &#125; return elements &#125; 先来看看调用方式：$.each(collection, function(index, item){ ... }) $.each 接收两个参数，第一个参数 elements 为需要遍历的数组或者对象，第二个 callback 为回调函数。 如果 elements 为数组，用 for 循环，调用 callback ，并且将数组索引 index 和元素值 item 传给回调函数作为参数；如果为对象，用 for···in 遍历属性值，并且将属性 key 及属性值传给回调函数作为参数。 注意回调函数调用了 call 方法，call 的第一个参数为当前元素值或当前属性值，所以回调函数的上下文变成了当前元素值或属性值，也就是说回调函数中的 this 指向的是 item 。这在dom集合的遍历中相当有用。 在遍历的时候，还对回调函数的返回值进行判断，如果回调函数返回 false （if (callback.call(elements[i], i, elements[i]) === false)） ，立即中断遍历。 $.each 调用结束后，会将遍历的数组或对象（ elements ）返回。 $.map可以遍历数组（类数组）或对象中的元素，根据回调函数的返回值，将返回值组成一个新的数组，并将该数组扁平化后返回，会将 null 及 undefined 排除。 123456789101112131415$.map = function(elements, callback) &#123; var value, values = [], i, key if (likeArray(elements)) for (i = 0; i &lt; elements.length; i++) &#123; value = callback(elements[i], i) if (value != null) values.push(value) &#125; else for (key in elements) &#123; value = callback(elements[key], key) if (value != null) values.push(value) &#125; return flatten(values) &#125; 先来看看调用方式： $.map(collection, function(item, index){ ... }) elements 为类数组或者对象。callback 为回调函数。当为类数组时，用 for 循环，当为对象时，用 for···in 循环。并且将对应的元素（属性值）及索引（属性名）传递给回调函数，如果回调函数的返回值不为 null 或者 undefined ，则将返回值存入新数组中，最后将新数组扁平化后返回。 $.camelCase该方法是将字符串转换成驼峰式的字符串 1$.camelCase = camelize $.camelCase 调用的是内部方法 camelize ,该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述，本篇文章就不再展开。 $.contains用来检查给定的父节点中是否包含有给定的子节点，源码如下： 123456789$.contains = document.documentElement.contains ? function(parent, node) &#123; return parent !== node &amp;&amp; parent.contains(node) &#125; : function(parent, node) &#123; while (node &amp;&amp; (node = node.parentNode)) if (node === parent) return true return false &#125; 先来看看调用：$.contains(parent, node) 参数 parent 为父子点，node 为子节点。 $.contains 的主体是一个三元表达式，返回的是一个匿名函数。三元表达式的条件是 document.documentElement.contains， 用来检测浏览器是否支持 contains 方法，如果支持，则直接调用 contains 方法，并且将 parent 和 node 为同一个元素的情况排除。 否则，返回另一外匿名函数。该函数会一直向上寻找 node 元素的父元素，如果能找到跟 parent 相等的父元素，则返回 true， 否则返回 false $.grep该函数其实就是数组的 filter 函数 123$.grep = function(elements, callback) &#123; return filter.call(elements, callback) &#125; 从源码中也可以看出，$.grep 调用的就是数组方法 filter $.inArray返回指定元素在数组中的索引值 123$.inArray = function(elem, array, i) &#123; return emptyArray.indexOf.call(array, elem, i) &#125; 先来看看调用 $.inArray(element, array, [fromIndex]) 第一个参数 element 为指定的元素，第二个参数为 array 为数组， 第三个参数 fromIndex 为可选参数，表示从哪个索引值开始向后查找。 $.inArray 其实调用的是数组的 indexOf 方法，所以传递的参数跟 indexOf 方法一致。 $.isArray判断是否为数组 1$.isArray = isArray $.isArray 调用的是内部方法 isArray ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isFunction判读是否为函数 1$.isFunction = isFunction $.isFunction 调用的是内部方法 isFunction ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isNumeric是否为数值 12345678910$.isNumeric = function(val) &#123; var num = Number(val), // 将参数转换为Number类型 type = typeof val return val != null &amp;&amp; type != 'boolean' &amp;&amp; (type != 'string' || val.length) &amp;&amp; !isNaN(num) &amp;&amp; isFinite(num) || false &#125; 判断是否为数值，需要满足以下条件 不为 null 不为布尔值 不为NaN(当传进来的参数不为数值或如&#39;123&#39;这样形式的字符串时，都会转换成NaN) 为有限数值 当传进来的参数为字符串的形式，如&#39;123&#39; 时，会用到下面这个条件来确保字符串为数字的形式，而不是如 123abc 这样的形式。(type != &#39;string&#39; || val.length) &amp;&amp; !isNaN(num) 。这个条件的包含逻辑如下：如果为字符串类型，并且为字符串的长度大于零，并且转换成数组后的结果不为NaN，则断定为数值。（因为 Number(&#39;&#39;) 的值为 0） $.isPlainObject是否为纯粹对象，即以 {} 常量或 new Object() 创建的对象 1$.isPlainObject = isPlainObject $.isPlainObject 调用的是内部方法isPlainObject ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.isWindow是否为浏览器的 window 对象 1$.isWindow = isWindow $.isWindow 调用的是内部方法 isWindow ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 $.noop空函数 1$.noop = function() &#123;&#125; 这个在需要传递回调函数作为参数，但是又不想在回调函数中做任何事情的时候会非常有用，这时，只需要传递一个空函数即可。 $.parseJSON将标准JSON格式的字符串解释成JSON 1if (window.JSON) $.parseJSON = JSON.parse 其实就是调用原生的 JSON.parse， 并且在浏览器不支持的情况下，zepto 还不提供这个方法。 $.trim删除字符串头尾的空格 123$.trim = function(str) &#123; return str == null ? \"\" : String.prototype.trim.call(str)&#125; 如果参数为 null 或者 undefined ，则直接返回空字符串，否则调用字符串原生的 trim 方法去除头尾的空格。 $.type类型检测 1$.type = type $.type 调用的是内部方法 type ，该方法在前一篇文章《读Zepto源码之内部方法》中已有阐述。 能检测的类型有 &quot;Boolean Number String Function Array Date RegExp Object Error&quot; 系列文章 读Zepto源码之代码结构 读 Zepto 源码之内部方法 参考 Zepto中文文档 Node.contains() Array.prototype.indexOf() String.prototype.trim() License署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0) 最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见： 作者：对角另一面","categories":[],"tags":[]}]}